{"ast":null,"code":"module.exports = version;\nmodule.exports.pin = pin;\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar exec = require('child_process').exec;\n\nvar root = null;\n\nfunction pin() {\n  return version().then(function (v) {\n    version.pinned = v;\n  });\n}\n\nfunction version(callback) {\n  // first find the package.json as this will be our root\n  var promise = findPackage(path.dirname(module.parent.filename)).then(function (dir) {\n    // now try to load the package\n    var v = require(path.resolve(dir, 'package.json')).version;\n\n    if (v && v !== '0.0.0-development') {\n      return v;\n    }\n\n    root = dir; // else we're in development, give the commit out\n    // get the last commit and whether the working dir is dirty\n\n    var promises = [branch().catch(function () {\n      return 'master';\n    }), commit().catch(function () {\n      return '<none>';\n    }), dirty().catch(function () {\n      return 0;\n    })]; // use the cached result as the export\n\n    return Promise.all(promises).then(function (res) {\n      var branch = res[0];\n      var commit = res[1];\n      var dirtyCount = parseInt(res[2], 10);\n      var curr = branch + ': ' + commit;\n\n      if (dirtyCount !== 0) {\n        curr += ' (' + dirtyCount + ' dirty files)';\n      }\n\n      return curr;\n    });\n  }).catch(function (error) {\n    console.log(error.stack);\n    throw error;\n  });\n\n  if (callback) {\n    promise.then(function (res) {\n      callback(null, res);\n    }, callback);\n  }\n\n  return promise;\n}\n\nfunction findPackage(dir) {\n  if (dir === '/') {\n    return Promise.reject(new Error('package not found'));\n  }\n\n  return new Promise(function (resolve) {\n    fs.stat(path.resolve(dir, 'package.json'), function (error, exists) {\n      if (error || !exists) {\n        return resolve(findPackage(path.resolve(dir, '..')));\n      }\n\n      resolve(dir);\n    });\n  });\n}\n\nfunction command(cmd) {\n  return new Promise(function (resolve, reject) {\n    exec(cmd, {\n      cwd: root\n    }, function (err, stdout, stderr) {\n      var error = stderr.trim();\n\n      if (error) {\n        return reject(new Error(error));\n      }\n\n      resolve(stdout.split('\\n').join(''));\n    });\n  });\n}\n\nfunction commit() {\n  return command('git rev-parse HEAD');\n}\n\nfunction branch() {\n  return command('git rev-parse --abbrev-ref HEAD');\n}\n\nfunction dirty() {\n  return command('expr $(git status --porcelain 2>/dev/null| ' + 'egrep \"^(M| M)\" | wc -l)');\n}","map":{"version":3,"sources":["/Users/jordanthomson/code/blog-with-Node-React/node_modules/nodemon/lib/version.js"],"names":["module","exports","version","pin","fs","require","path","exec","root","then","v","pinned","callback","promise","findPackage","dirname","parent","filename","dir","resolve","promises","branch","catch","commit","dirty","Promise","all","res","dirtyCount","parseInt","curr","error","console","log","stack","reject","Error","stat","exists","command","cmd","cwd","err","stdout","stderr","trim","split","join"],"mappings":"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","sourcesContent":["module.exports = version;\nmodule.exports.pin = pin;\n\nvar fs = require('fs');\nvar path = require('path');\nvar exec = require('child_process').exec;\nvar root = null;\n\nfunction pin() {\n  return version().then(function (v) {\n    version.pinned = v;\n  });\n}\n\nfunction version(callback) {\n  // first find the package.json as this will be our root\n  var promise = findPackage(path.dirname(module.parent.filename))\n    .then(function (dir) {\n      // now try to load the package\n      var v = require(path.resolve(dir, 'package.json')).version;\n\n      if (v && v !== '0.0.0-development') {\n        return v;\n      }\n\n      root = dir;\n\n      // else we're in development, give the commit out\n      // get the last commit and whether the working dir is dirty\n      var promises = [\n        branch().catch(function () { return 'master'; }),\n        commit().catch(function () { return '<none>'; }),\n        dirty().catch(function () { return 0; }),\n      ];\n\n      // use the cached result as the export\n      return Promise.all(promises).then(function (res) {\n        var branch = res[0];\n        var commit = res[1];\n        var dirtyCount = parseInt(res[2], 10);\n        var curr = branch + ': ' + commit;\n        if (dirtyCount !== 0) {\n          curr += ' (' + dirtyCount + ' dirty files)';\n        }\n\n        return curr;\n      });\n    }).catch(function (error) {\n      console.log(error.stack);\n      throw error;\n    });\n\n  if (callback) {\n    promise.then(function (res) {\n      callback(null, res);\n    }, callback);\n  }\n\n  return promise;\n}\n\nfunction findPackage(dir) {\n  if (dir === '/') {\n    return Promise.reject(new Error('package not found'));\n  }\n  return new Promise(function (resolve) {\n    fs.stat(path.resolve(dir, 'package.json'), function (error, exists) {\n      if (error || !exists) {\n        return resolve(findPackage(path.resolve(dir, '..')));\n      }\n\n      resolve(dir);\n    });\n  });\n}\n\nfunction command(cmd) {\n  return new Promise(function (resolve, reject) {\n    exec(cmd, { cwd: root }, function (err, stdout, stderr) {\n      var error = stderr.trim();\n      if (error) {\n        return reject(new Error(error));\n      }\n      resolve(stdout.split('\\n').join(''));\n    });\n  });\n}\n\nfunction commit() {\n  return command('git rev-parse HEAD');\n}\n\nfunction branch() {\n  return command('git rev-parse --abbrev-ref HEAD');\n}\n\nfunction dirty() {\n  return command('expr $(git status --porcelain 2>/dev/null| ' +\n    'egrep \"^(M| M)\" | wc -l)');\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst fs = require('fs');\n\nconst sysPath = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst readdirp = require('readdirp');\n\nconst anymatch = require('anymatch').default;\n\nconst globParent = require('glob-parent');\n\nconst isGlob = require('is-glob');\n\nconst braces = require('braces');\n\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\n\nconst FsEventsHandler = require('./lib/fsevents-handler');\n\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n  STR_CLOSE,\n  STR_END,\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n  isWindows,\n  isMacos,\n  isIBMi\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\n\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = paths_ => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n\n  return paths.map(normalizePathToUnix);\n}; // If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\n\n\nconst toUnix = string => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n\n  if (prepend) {\n    str = SLASH + str;\n  }\n\n  return str;\n}; // Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\n\n\nconst normalizePathToUnix = path => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => path => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\n\n\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n    const dir = this.path;\n\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return items.has(item);\n  }\n  /**\n   * @returns {Array<String>}\n   */\n\n\n  getChildren() {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\n\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(parts => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: this.fullWatchPath\n      };\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n  }\n\n  filterPath(entry) {\n    const {\n      stats\n    } = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n    return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach(path => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some(parts => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n\n}\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\n\n\nclass FSWatcher extends EventEmitter {\n  // Not indenting methods for history sake; for now.\n  constructor(_opts) {\n    super();\n    const opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n\n    this._watched = new Map();\n    /** @type {Map<String, Array>} */\n\n    this._closers = new Map();\n    /** @type {Set<String>} */\n\n    this._ignoredPaths = new Set();\n    /** @type {Map<ThrottleType, Map>} */\n\n    this._throttled = new Map();\n    /** @type {Map<Path, String|Boolean>} */\n\n    this._symlinkPaths = new Map();\n    this._streams = new Set();\n    this.closed = false; // Set up default options.\n\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.\n\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.\n\n    const canUseFsEvents = FsEventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    } // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n\n\n    if (isIBMi) {\n      opts.usePolling = true;\n    } // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n\n\n    const envPoll = process.env.CHOKIDAR_USEPOLLING;\n\n    if (envPoll !== undefined) {\n      const envLower = envPoll.toLowerCase();\n\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n\n    const envInterval = process.env.CHOKIDAR_INTERVAL;\n\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    } // Editor atomic write normalization enabled by default with fs.watch\n\n\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) this._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    const awf = opts.awaitWriteFinish;\n\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      this._pendingWrites = new Map();\n    }\n\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    let readyCalls = 0;\n\n    this._emitReady = () => {\n      readyCalls++;\n\n      if (readyCalls >= this._readyCount) {\n        this._emitReady = EMPTY_FN;\n        this._readyEmitted = true; // use process.nextTick to allow time for listener to be bound\n\n        process.nextTick(() => this.emit(EV_READY));\n      }\n    };\n\n    this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n\n    this._readyEmitted = false;\n    this.options = opts; // Initialize with proper watcher.\n\n    if (opts.useFsEvents) {\n      this._fsEventsHandler = new FsEventsHandler(this);\n    } else {\n      this._nodeFsHandler = new NodeFsHandler(this);\n    } // You’re frozen when your heart’s not open.\n\n\n    Object.freeze(opts);\n  } // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n\n\n  add(paths_, _origAdd, _internal) {\n    const {\n      cwd,\n      disableGlobbing\n    } = this.options;\n    this.closed = false;\n    let paths = unifyPaths(paths_);\n\n    if (cwd) {\n      paths = paths.map(path => {\n        const absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\n        if (disableGlobbing || !isGlob(path)) {\n          return absPath;\n        }\n\n        return normalizePath(absPath);\n      });\n    } // set aside negated glob strings\n\n\n    paths = paths.filter(path => {\n      if (path.startsWith(BANG)) {\n        this._ignoredPaths.add(path.slice(1));\n\n        return false;\n      } // if a path is being added that was previously ignored, stop ignoring it\n\n\n      this._ignoredPaths.delete(path);\n\n      this._ignoredPaths.delete(path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n\n      this._userIgnored = undefined;\n      return true;\n    });\n\n    if (this.options.useFsEvents && this._fsEventsHandler) {\n      if (!this._readyCount) this._readyCount = paths.length;\n      if (this.options.persistent) this._readyCount *= 2;\n      paths.forEach(path => this._fsEventsHandler._addToFsEvents(path));\n    } else {\n      if (!this._readyCount) this._readyCount = 0;\n      this._readyCount += paths.length;\n      Promise.all(paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })).then(results => {\n        if (this.closed) return;\n        results.filter(item => item).forEach(item => {\n          this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n        });\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Close watchers or start ignoring events from specified paths.\n   * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n   * @returns {FSWatcher} for chaining\n  */\n\n\n  unwatch(paths_) {\n    if (this.closed) return this;\n    const paths = unifyPaths(paths_);\n    const {\n      cwd\n    } = this.options;\n    paths.forEach(path => {\n      // convert to absolute path unless relative path already matches\n      if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n        if (cwd) path = sysPath.join(cwd, path);\n        path = sysPath.resolve(path);\n      }\n\n      this._closePath(path);\n\n      this._ignoredPaths.add(path);\n\n      if (this._watched.has(path)) {\n        this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n      } // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n\n      this._userIgnored = undefined;\n    });\n    return this;\n  }\n  /**\n   * Close watchers and remove all listeners from watched paths.\n   * @returns {Promise<void>}.\n  */\n\n\n  close() {\n    if (this.closed) return this._closePromise;\n    this.closed = true; // Memory management.\n\n    this.removeAllListeners();\n    const closers = [];\n\n    this._closers.forEach(closerList => closerList.forEach(closer => {\n      const promise = closer();\n      if (promise instanceof Promise) closers.push(promise);\n    }));\n\n    this._streams.forEach(stream => stream.destroy());\n\n    this._userIgnored = undefined;\n    this._readyCount = 0;\n    this._readyEmitted = false;\n\n    this._watched.forEach(dirent => dirent.dispose());\n\n    ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n      this[`_${key}`].clear();\n    });\n    this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n    return this._closePromise;\n  }\n  /**\n   * Expose list of watched paths\n   * @returns {Object} for chaining\n  */\n\n\n  getWatched() {\n    const watchList = {};\n\n    this._watched.forEach((entry, dir) => {\n      const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n      watchList[key || ONE_DOT] = entry.getChildren().sort();\n    });\n\n    return watchList;\n  }\n\n  emitWithAll(event, args) {\n    this.emit(...args);\n    if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n  } // Common helpers\n  // --------------\n\n  /**\n   * Normalize and emit events.\n   * Calling _emit DOES NOT MEAN emit() would be called!\n   * @param {EventName} event Type of event\n   * @param {Path} path File or directory path\n   * @param {*=} val1 arguments to be passed with event\n   * @param {*=} val2\n   * @param {*=} val3\n   * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n\n\n  async _emit(event, path, val1, val2, val3) {\n    if (this.closed) return;\n    const opts = this.options;\n    if (isWindows) path = sysPath.normalize(path);\n    if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n    /** @type Array<any> */\n\n    const args = [event, path];\n    if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n    const awf = opts.awaitWriteFinish;\n    let pw;\n\n    if (awf && (pw = this._pendingWrites.get(path))) {\n      pw.lastChange = new Date();\n      return this;\n    }\n\n    if (opts.atomic) {\n      if (event === EV_UNLINK) {\n        this._pendingUnlinks.set(path, args);\n\n        setTimeout(() => {\n          this._pendingUnlinks.forEach((entry, path) => {\n            this.emit(...entry);\n            this.emit(EV_ALL, ...entry);\n\n            this._pendingUnlinks.delete(path);\n          });\n        }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n        return this;\n      }\n\n      if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n        event = args[0] = EV_CHANGE;\n\n        this._pendingUnlinks.delete(path);\n      }\n    }\n\n    if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n      const awfEmit = (err, stats) => {\n        if (err) {\n          event = args[0] = EV_ERROR;\n          args[1] = err;\n          this.emitWithAll(event, args);\n        } else if (stats) {\n          // if stats doesn't exist the file must have been deleted\n          if (args.length > 2) {\n            args[2] = stats;\n          } else {\n            args.push(stats);\n          }\n\n          this.emitWithAll(event, args);\n        }\n      };\n\n      this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\n      return this;\n    }\n\n    if (event === EV_CHANGE) {\n      const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n      if (isThrottled) return this;\n    }\n\n    if (opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {\n      const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n      let stats;\n\n      try {\n        stats = await stat(fullPath);\n      } catch (err) {} // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n\n\n      if (!stats || this.closed) return;\n      args.push(stats);\n    }\n\n    this.emitWithAll(event, args);\n    return this;\n  }\n  /**\n   * Common handler for errors\n   * @param {Error} error\n   * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n\n\n  _handleError(error) {\n    const code = error && error.code;\n\n    if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n      this.emit(EV_ERROR, error);\n    }\n\n    return error || this.closed;\n  }\n  /**\n   * Helper utility for throttling\n   * @param {ThrottleType} actionType type being throttled\n   * @param {Path} path being acted upon\n   * @param {Number} timeout duration of time to suppress duplicate actions\n   * @returns {Object|false} tracking object or false if action should be suppressed\n   */\n\n\n  _throttle(actionType, path, timeout) {\n    if (!this._throttled.has(actionType)) {\n      this._throttled.set(actionType, new Map());\n    }\n    /** @type {Map<Path, Object>} */\n\n\n    const action = this._throttled.get(actionType);\n    /** @type {Object} */\n\n\n    const actionPath = action.get(path);\n\n    if (actionPath) {\n      actionPath.count++;\n      return false;\n    }\n\n    let timeoutObject;\n\n    const clear = () => {\n      const item = action.get(path);\n      const count = item ? item.count : 0;\n      action.delete(path);\n      clearTimeout(timeoutObject);\n      if (item) clearTimeout(item.timeoutObject);\n      return count;\n    };\n\n    timeoutObject = setTimeout(clear, timeout);\n    const thr = {\n      timeoutObject,\n      clear,\n      count: 0\n    };\n    action.set(path, thr);\n    return thr;\n  }\n\n  _incrReadyCount() {\n    return this._readyCount++;\n  }\n  /**\n   * Awaits write operation to finish.\n   * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n   * @param {Path} path being acted upon\n   * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n   * @param {EventName} event\n   * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n   */\n\n\n  _awaitWriteFinish(path, threshold, event, awfEmit) {\n    let timeoutHandler;\n    let fullPath = path;\n\n    if (this.options.cwd && !sysPath.isAbsolute(path)) {\n      fullPath = sysPath.join(this.options.cwd, path);\n    }\n\n    const now = new Date();\n\n    const awaitWriteFinish = prevStat => {\n      fs.stat(fullPath, (err, curStat) => {\n        if (err || !this._pendingWrites.has(path)) {\n          if (err && err.code !== 'ENOENT') awfEmit(err);\n          return;\n        }\n\n        const now = Number(new Date());\n\n        if (prevStat && curStat.size !== prevStat.size) {\n          this._pendingWrites.get(path).lastChange = now;\n        }\n\n        const pw = this._pendingWrites.get(path);\n\n        const df = now - pw.lastChange;\n\n        if (df >= threshold) {\n          this._pendingWrites.delete(path);\n\n          awfEmit(undefined, curStat);\n        } else {\n          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);\n        }\n      });\n    };\n\n    if (!this._pendingWrites.has(path)) {\n      this._pendingWrites.set(path, {\n        lastChange: now,\n        cancelWait: () => {\n          this._pendingWrites.delete(path);\n\n          clearTimeout(timeoutHandler);\n          return event;\n        }\n      });\n\n      timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n    }\n  }\n\n  _getGlobIgnored() {\n    return [...this._ignoredPaths.values()];\n  }\n  /**\n   * Determines whether user has asked to ignore this path.\n   * @param {Path} path filepath or dir\n   * @param {fs.Stats=} stats result of fs.stat\n   * @returns {Boolean}\n   */\n\n\n  _isIgnored(path, stats) {\n    if (this.options.atomic && DOT_RE.test(path)) return true;\n\n    if (!this._userIgnored) {\n      const {\n        cwd\n      } = this.options;\n      const ign = this.options.ignored;\n      const ignored = ign && ign.map(normalizeIgnored(cwd));\n      const paths = arrify(ignored).filter(path => typeof path === STRING_TYPE && !isGlob(path)).map(path => path + SLASH_GLOBSTAR);\n\n      const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n\n      this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n    }\n\n    return this._userIgnored([path, stats]);\n  }\n\n  _isntIgnored(path, stat) {\n    return !this._isIgnored(path, stat);\n  }\n  /**\n   * Provides a set of common helpers and properties relating to symlink and glob handling.\n   * @param {Path} path file, directory, or glob pattern being watched\n   * @param {Number=} depth at any depth > 0, this isn't a glob\n   * @returns {WatchHelper} object containing helpers for this path\n   */\n\n\n  _getWatchHelpers(path, depth) {\n    const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n    const follow = this.options.followSymlinks;\n    return new WatchHelper(path, watchPath, follow, this);\n  } // Directory helpers\n  // -----------------\n\n  /**\n   * Provides directory tracking objects\n   * @param {String} directory path of the directory\n   * @returns {DirEntry} the directory's tracking object\n   */\n\n\n  _getWatchedDir(directory) {\n    if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n    const dir = sysPath.resolve(directory);\n    if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n    return this._watched.get(dir);\n  } // File helpers\n  // ------------\n\n  /**\n   * Check for read permissions.\n   * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n   * @param {fs.Stats} stats - object, result of fs_stat\n   * @returns {Boolean} indicates whether the file can be read\n  */\n\n\n  _hasReadPermissions(stats) {\n    if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint\n\n    const md = stats && Number.parseInt(stats.mode, 10);\n    const st = md & 0o777;\n    const it = Number.parseInt(st.toString(8)[0], 10);\n    return Boolean(4 & it);\n  }\n  /**\n   * Handles emitting unlink events for\n   * files and directories, and via recursion, for\n   * files and directories within directories that are unlinked\n   * @param {String} directory within which the following item is located\n   * @param {String} item      base path of item/directory\n   * @returns {void}\n  */\n\n\n  _remove(directory, item, isDirectory) {\n    // if what is being deleted is a directory, get that directory's paths\n    // for recursive deleting and cleaning of watched object\n    // if it is not a directory, nestedDirectoryChildren will be empty array\n    const path = sysPath.join(directory, item);\n    const fullPath = sysPath.resolve(path);\n    isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously\n    // via multiple paths (such as _handleFile and _handleDir)\n\n    if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return\n\n    if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n      this.add(directory, item, true);\n    } // This will create a new entry in the watched object in either case\n    // so we got to do the directory check beforehand\n\n\n    const wp = this._getWatchedDir(path);\n\n    const nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.\n\n    nestedDirectoryChildren.forEach(nested => this._remove(path, nested)); // Check if item was on the watched list and remove it\n\n    const parent = this._getWatchedDir(directory);\n\n    const wasTracked = parent.has(item);\n    parent.remove(item); // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n    // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n    // but never removed from the map in case the path was deleted.\n    // This leads to an incorrect state if the path was recreated:\n    // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n\n    if (this._symlinkPaths.has(fullPath)) {\n      this._symlinkPaths.delete(fullPath);\n    } // If we wait for this file to be fully written, cancel the wait.\n\n\n    let relPath = path;\n    if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n\n    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n      const event = this._pendingWrites.get(relPath).cancelWait();\n\n      if (event === EV_ADD) return;\n    } // The Entry will either be a directory that just got removed\n    // or a bogus entry to a file, in either case we have to remove it\n\n\n    this._watched.delete(path);\n\n    this._watched.delete(fullPath);\n\n    const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n    if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name\n\n    if (!this.options.useFsEvents) {\n      this._closePath(path);\n    }\n  }\n  /**\n   * Closes all watchers for a path\n   * @param {Path} path\n   */\n\n\n  _closePath(path) {\n    this._closeFile(path);\n\n    const dir = sysPath.dirname(path);\n\n    this._getWatchedDir(dir).remove(sysPath.basename(path));\n  }\n  /**\n   * Closes only file-specific watchers\n   * @param {Path} path\n   */\n\n\n  _closeFile(path) {\n    const closers = this._closers.get(path);\n\n    if (!closers) return;\n    closers.forEach(closer => closer());\n\n    this._closers.delete(path);\n  }\n  /**\n   *\n   * @param {Path} path\n   * @param {Function} closer\n   */\n\n\n  _addPathCloser(path, closer) {\n    if (!closer) return;\n\n    let list = this._closers.get(path);\n\n    if (!list) {\n      list = [];\n\n      this._closers.set(path, list);\n    }\n\n    list.push(closer);\n  }\n\n  _readdirp(root, opts) {\n    if (this.closed) return;\n    const options = {\n      type: EV_ALL,\n      alwaysStat: true,\n      lstat: true,\n      ...opts\n    };\n    let stream = readdirp(root, options);\n\n    this._streams.add(stream);\n\n    stream.once(STR_CLOSE, () => {\n      stream = undefined;\n    });\n    stream.once(STR_END, () => {\n      if (stream) {\n        this._streams.delete(stream);\n\n        stream = undefined;\n      }\n    });\n    return stream;\n  }\n\n} // Export FSWatcher class\n\n\nexports.FSWatcher = FSWatcher;\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\n\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;","map":{"version":3,"sources":["/Users/jordanthomson/code/blog-with-Node-React/node_modules/chokidar/index.js"],"names":["EventEmitter","require","fs","sysPath","promisify","readdirp","anymatch","default","globParent","isGlob","braces","normalizePath","NodeFsHandler","FsEventsHandler","EV_ALL","EV_READY","EV_ADD","EV_CHANGE","EV_UNLINK","EV_ADD_DIR","EV_UNLINK_DIR","EV_RAW","EV_ERROR","STR_CLOSE","STR_END","BACK_SLASH_RE","DOUBLE_SLASH_RE","SLASH_OR_BACK_SLASH_RE","DOT_RE","REPLACER_RE","SLASH","SLASH_SLASH","BRACE_START","BANG","ONE_DOT","TWO_DOTS","GLOBSTAR","SLASH_GLOBSTAR","ANYMATCH_OPTS","STRING_TYPE","FUNCTION_TYPE","EMPTY_STR","EMPTY_FN","isWindows","isMacos","isIBMi","stat","readdir","arrify","value","Array","isArray","flatten","list","result","forEach","item","push","unifyPaths","paths_","paths","every","p","TypeError","map","normalizePathToUnix","toUnix","string","str","replace","prepend","startsWith","match","path","normalize","normalizeIgnored","cwd","isAbsolute","join","getAbsolutePath","slice","undef","opts","key","undefined","DirEntry","constructor","dir","removeWatcher","_removeWatcher","items","Set","add","remove","delete","size","err","dirname","basename","has","getChildren","values","dispose","clear","Object","freeze","STAT_METHOD_F","STAT_METHOD_L","WatchHelper","watchPath","follow","fsw","fullWatchPath","resolve","hasGlob","globSymlink","globFilter","dirParts","getDirParts","parts","length","pop","followSymlinks","statMethod","checkGlobSymlink","entry","fullParentDir","realPath","linkPath","fullPath","entryPath","relative","filterPath","stats","isSymbolicLink","filterDir","resolvedPath","matchesGlob","_isntIgnored","_hasReadPermissions","expandedPath","includes","expand","split","entryParts","globstar","unmatchedGlob","some","part","i","FSWatcher","_opts","assign","_watched","Map","_closers","_ignoredPaths","_throttled","_symlinkPaths","_streams","closed","persistent","ignoreInitial","ignorePermissionErrors","interval","binaryInterval","disableGlobbing","enableBinaryInterval","useFsEvents","usePolling","canUseFsEvents","canUse","envPoll","process","env","CHOKIDAR_USEPOLLING","envLower","toLowerCase","envInterval","CHOKIDAR_INTERVAL","Number","parseInt","atomic","_pendingUnlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","ignored","readyCalls","_emitReady","_readyCount","_readyEmitted","nextTick","emit","_emitRaw","args","options","_fsEventsHandler","_nodeFsHandler","_origAdd","_internal","absPath","filter","_userIgnored","_addToFsEvents","Promise","all","res","_addToNodeFs","then","results","unwatch","_closePath","close","_closePromise","removeAllListeners","closers","closerList","closer","promise","stream","destroy","dirent","getWatched","watchList","sort","emitWithAll","event","_emit","val1","val2","val3","pw","get","lastChange","Date","set","setTimeout","awfEmit","_awaitWriteFinish","isThrottled","_throttle","alwaysStat","_handleError","error","code","actionType","timeout","action","actionPath","count","timeoutObject","clearTimeout","thr","_incrReadyCount","threshold","timeoutHandler","now","prevStat","curStat","df","cancelWait","_getGlobIgnored","_isIgnored","test","ign","concat","_getWatchHelpers","depth","_getWatchedDir","directory","_boundRemove","_remove","bind","md","mode","st","it","toString","Boolean","isDirectory","wp","nestedDirectoryChildren","nested","parent","wasTracked","relPath","eventName","_closeFile","_addPathCloser","_readdirp","root","type","lstat","once","exports","watch","watcher"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAmBC,OAAO,CAAC,QAAD,CAAhC;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,MAAD,CAAvB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAgBH,OAAO,CAAC,MAAD,CAA7B;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,UAAD,CAAP,CAAoBM,OAArC;;AACA,MAAMC,UAAU,GAAGP,OAAO,CAAC,aAAD,CAA1B;;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMS,MAAM,GAAGT,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMU,aAAa,GAAGV,OAAO,CAAC,gBAAD,CAA7B;;AAEA,MAAMW,aAAa,GAAGX,OAAO,CAAC,sBAAD,CAA7B;;AACA,MAAMY,eAAe,GAAGZ,OAAO,CAAC,wBAAD,CAA/B;;AACA,MAAM;AACJa,EAAAA,MADI;AAEJC,EAAAA,QAFI;AAGJC,EAAAA,MAHI;AAIJC,EAAAA,SAJI;AAKJC,EAAAA,SALI;AAMJC,EAAAA,UANI;AAOJC,EAAAA,aAPI;AAQJC,EAAAA,MARI;AASJC,EAAAA,QATI;AAWJC,EAAAA,SAXI;AAYJC,EAAAA,OAZI;AAcJC,EAAAA,aAdI;AAeJC,EAAAA,eAfI;AAgBJC,EAAAA,sBAhBI;AAiBJC,EAAAA,MAjBI;AAkBJC,EAAAA,WAlBI;AAoBJC,EAAAA,KApBI;AAqBJC,EAAAA,WArBI;AAsBJC,EAAAA,WAtBI;AAuBJC,EAAAA,IAvBI;AAwBJC,EAAAA,OAxBI;AAyBJC,EAAAA,QAzBI;AA0BJC,EAAAA,QA1BI;AA2BJC,EAAAA,cA3BI;AA4BJC,EAAAA,aA5BI;AA6BJC,EAAAA,WA7BI;AA8BJC,EAAAA,aA9BI;AA+BJC,EAAAA,SA/BI;AAgCJC,EAAAA,QAhCI;AAkCJC,EAAAA,SAlCI;AAmCJC,EAAAA,OAnCI;AAoCJC,EAAAA;AApCI,IAqCF5C,OAAO,CAAC,iBAAD,CArCX;;AAuCA,MAAM6C,IAAI,GAAG1C,SAAS,CAACF,EAAE,CAAC4C,IAAJ,CAAtB;AACA,MAAMC,OAAO,GAAG3C,SAAS,CAACF,EAAE,CAAC6C,OAAJ,CAAzB;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,MAAM,GAAG,CAACC,KAAK,GAAG,EAAT,KAAgBC,KAAK,CAACC,OAAN,CAAcF,KAAd,IAAuBA,KAAvB,GAA+B,CAACA,KAAD,CAA9D;;AACA,MAAMG,OAAO,GAAG,CAACC,IAAD,EAAOC,MAAM,GAAG,EAAhB,KAAuB;AACrCD,EAAAA,IAAI,CAACE,OAAL,CAAaC,IAAI,IAAI;AACnB,QAAIN,KAAK,CAACC,OAAN,CAAcK,IAAd,CAAJ,EAAyB;AACvBJ,MAAAA,OAAO,CAACI,IAAD,EAAOF,MAAP,CAAP;AACD,KAFD,MAEO;AACLA,MAAAA,MAAM,CAACG,IAAP,CAAYD,IAAZ;AACD;AACF,GAND;AAOA,SAAOF,MAAP;AACD,CATD;;AAWA,MAAMI,UAAU,GAAIC,MAAD,IAAY;AAC7B;AACF;AACA;AACE,QAAMC,KAAK,GAAGR,OAAO,CAACJ,MAAM,CAACW,MAAD,CAAP,CAArB;;AACA,MAAI,CAACC,KAAK,CAACC,KAAN,CAAYC,CAAC,IAAI,OAAOA,CAAP,KAAavB,WAA9B,CAAL,EAAiD;AAC/C,UAAM,IAAIwB,SAAJ,CAAe,sCAAqCH,KAAM,EAA1D,CAAN;AACD;;AACD,SAAOA,KAAK,CAACI,GAAN,CAAUC,mBAAV,CAAP;AACD,CATD,C,CAWA;AACA;;;AACA,MAAMC,MAAM,GAAIC,MAAD,IAAY;AACzB,MAAIC,GAAG,GAAGD,MAAM,CAACE,OAAP,CAAe5C,aAAf,EAA8BK,KAA9B,CAAV;AACA,MAAIwC,OAAO,GAAG,KAAd;;AACA,MAAIF,GAAG,CAACG,UAAJ,CAAexC,WAAf,CAAJ,EAAiC;AAC/BuC,IAAAA,OAAO,GAAG,IAAV;AACD;;AACD,SAAOF,GAAG,CAACI,KAAJ,CAAU9C,eAAV,CAAP,EAAmC;AACjC0C,IAAAA,GAAG,GAAGA,GAAG,CAACC,OAAJ,CAAY3C,eAAZ,EAA6BI,KAA7B,CAAN;AACD;;AACD,MAAIwC,OAAJ,EAAa;AACXF,IAAAA,GAAG,GAAGtC,KAAK,GAAGsC,GAAd;AACD;;AACD,SAAOA,GAAP;AACD,CAbD,C,CAeA;AACA;;;AACA,MAAMH,mBAAmB,GAAIQ,IAAD,IAAUP,MAAM,CAAC/D,OAAO,CAACuE,SAAR,CAAkBR,MAAM,CAACO,IAAD,CAAxB,CAAD,CAA5C;;AAEA,MAAME,gBAAgB,GAAG,CAACC,GAAG,GAAGnC,SAAP,KAAsBgC,IAAD,IAAU;AACtD,MAAI,OAAOA,IAAP,KAAgBlC,WAApB,EAAiC,OAAOkC,IAAP;AACjC,SAAOR,mBAAmB,CAAC9D,OAAO,CAAC0E,UAAR,CAAmBJ,IAAnB,IAA2BA,IAA3B,GAAkCtE,OAAO,CAAC2E,IAAR,CAAaF,GAAb,EAAkBH,IAAlB,CAAnC,CAA1B;AACD,CAHD;;AAKA,MAAMM,eAAe,GAAG,CAACN,IAAD,EAAOG,GAAP,KAAe;AACrC,MAAIzE,OAAO,CAAC0E,UAAR,CAAmBJ,IAAnB,CAAJ,EAA8B;AAC5B,WAAOA,IAAP;AACD;;AACD,MAAIA,IAAI,CAACF,UAAL,CAAgBtC,IAAhB,CAAJ,EAA2B;AACzB,WAAOA,IAAI,GAAG9B,OAAO,CAAC2E,IAAR,CAAaF,GAAb,EAAkBH,IAAI,CAACO,KAAL,CAAW,CAAX,CAAlB,CAAd;AACD;;AACD,SAAO7E,OAAO,CAAC2E,IAAR,CAAaF,GAAb,EAAkBH,IAAlB,CAAP;AACD,CARD;;AAUA,MAAMQ,KAAK,GAAG,CAACC,IAAD,EAAOC,GAAP,KAAeD,IAAI,CAACC,GAAD,CAAJ,KAAcC,SAA3C;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,QAAN,CAAe;AACb;AACF;AACA;AACA;AACEC,EAAAA,WAAW,CAACC,GAAD,EAAMC,aAAN,EAAqB;AAC9B,SAAKf,IAAL,GAAYc,GAAZ;AACA,SAAKE,cAAL,GAAsBD,aAAtB;AACA;;AACA,SAAKE,KAAL,GAAa,IAAIC,GAAJ,EAAb;AACD;;AAEDC,EAAAA,GAAG,CAACpC,IAAD,EAAO;AACR,UAAM;AAACkC,MAAAA;AAAD,QAAU,IAAhB;AACA,QAAI,CAACA,KAAL,EAAY;AACZ,QAAIlC,IAAI,KAAKtB,OAAT,IAAoBsB,IAAI,KAAKrB,QAAjC,EAA2CuD,KAAK,CAACE,GAAN,CAAUpC,IAAV;AAC5C;;AAEW,QAANqC,MAAM,CAACrC,IAAD,EAAO;AACjB,UAAM;AAACkC,MAAAA;AAAD,QAAU,IAAhB;AACA,QAAI,CAACA,KAAL,EAAY;AACZA,IAAAA,KAAK,CAACI,MAAN,CAAatC,IAAb;AACA,QAAIkC,KAAK,CAACK,IAAN,GAAa,CAAjB,EAAoB;AAEpB,UAAMR,GAAG,GAAG,KAAKd,IAAjB;;AACA,QAAI;AACF,YAAM1B,OAAO,CAACwC,GAAD,CAAb;AACD,KAFD,CAEE,OAAOS,GAAP,EAAY;AACZ,UAAI,KAAKP,cAAT,EAAyB;AACvB,aAAKA,cAAL,CAAoBtF,OAAO,CAAC8F,OAAR,CAAgBV,GAAhB,CAApB,EAA0CpF,OAAO,CAAC+F,QAAR,CAAiBX,GAAjB,CAA1C;AACD;AACF;AACF;;AAEDY,EAAAA,GAAG,CAAC3C,IAAD,EAAO;AACR,UAAM;AAACkC,MAAAA;AAAD,QAAU,IAAhB;AACA,QAAI,CAACA,KAAL,EAAY;AACZ,WAAOA,KAAK,CAACS,GAAN,CAAU3C,IAAV,CAAP;AACD;AAED;AACF;AACA;;;AACE4C,EAAAA,WAAW,GAAG;AACZ,UAAM;AAACV,MAAAA;AAAD,QAAU,IAAhB;AACA,QAAI,CAACA,KAAL,EAAY;AACZ,WAAO,CAAC,GAAGA,KAAK,CAACW,MAAN,EAAJ,CAAP;AACD;;AAEDC,EAAAA,OAAO,GAAG;AACR,SAAKZ,KAAL,CAAWa,KAAX;AACA,WAAO,KAAK9B,IAAZ;AACA,WAAO,KAAKgB,cAAZ;AACA,WAAO,KAAKC,KAAZ;AACAc,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd;AACD;;AAvDY;;AA0Df,MAAMC,aAAa,GAAG,MAAtB;AACA,MAAMC,aAAa,GAAG,OAAtB;;AACA,MAAMC,WAAN,CAAkB;AAChBtB,EAAAA,WAAW,CAACb,IAAD,EAAOoC,SAAP,EAAkBC,MAAlB,EAA0BC,GAA1B,EAA+B;AACxC,SAAKA,GAAL,GAAWA,GAAX;AACA,SAAKtC,IAAL,GAAYA,IAAI,GAAGA,IAAI,CAACJ,OAAL,CAAaxC,WAAb,EAA0BY,SAA1B,CAAnB;AACA,SAAKoE,SAAL,GAAiBA,SAAjB;AACA,SAAKG,aAAL,GAAqB7G,OAAO,CAAC8G,OAAR,CAAgBJ,SAAhB,CAArB;AACA,SAAKK,OAAL,GAAeL,SAAS,KAAKpC,IAA7B;AACA;;AACA,QAAIA,IAAI,KAAKhC,SAAb,EAAwB,KAAKyE,OAAL,GAAe,KAAf;AACxB,SAAKC,WAAL,GAAmB,KAAKD,OAAL,IAAgBJ,MAAhB,GAAyB1B,SAAzB,GAAqC,KAAxD;AACA,SAAKgC,UAAL,GAAkB,KAAKF,OAAL,GAAe5G,QAAQ,CAACmE,IAAD,EAAOW,SAAP,EAAkB9C,aAAlB,CAAvB,GAA0D,KAA5E;AACA,SAAK+E,QAAL,GAAgB,KAAKC,WAAL,CAAiB7C,IAAjB,CAAhB;AACA,SAAK4C,QAAL,CAAc9D,OAAd,CAAuBgE,KAAD,IAAW;AAC/B,UAAIA,KAAK,CAACC,MAAN,GAAe,CAAnB,EAAsBD,KAAK,CAACE,GAAN;AACvB,KAFD;AAGA,SAAKC,cAAL,GAAsBZ,MAAtB;AACA,SAAKa,UAAL,GAAkBb,MAAM,GAAGJ,aAAH,GAAmBC,aAA3C;AACD;;AAEDiB,EAAAA,gBAAgB,CAACC,KAAD,EAAQ;AACtB;AACA;AACA,QAAI,KAAKV,WAAL,KAAqB/B,SAAzB,EAAoC;AAClC,WAAK+B,WAAL,GAAmBU,KAAK,CAACC,aAAN,KAAwB,KAAKd,aAA7B,GACjB,KADiB,GACT;AAACe,QAAAA,QAAQ,EAAEF,KAAK,CAACC,aAAjB;AAAgCE,QAAAA,QAAQ,EAAE,KAAKhB;AAA/C,OADV;AAED;;AAED,QAAI,KAAKG,WAAT,EAAsB;AACpB,aAAOU,KAAK,CAACI,QAAN,CAAe5D,OAAf,CAAuB,KAAK8C,WAAL,CAAiBY,QAAxC,EAAkD,KAAKZ,WAAL,CAAiBa,QAAnE,CAAP;AACD;;AAED,WAAOH,KAAK,CAACI,QAAb;AACD;;AAEDC,EAAAA,SAAS,CAACL,KAAD,EAAQ;AACf,WAAO1H,OAAO,CAAC2E,IAAR,CAAa,KAAK+B,SAAlB,EACL1G,OAAO,CAACgI,QAAR,CAAiB,KAAKtB,SAAtB,EAAiC,KAAKe,gBAAL,CAAsBC,KAAtB,CAAjC,CADK,CAAP;AAGD;;AAEDO,EAAAA,UAAU,CAACP,KAAD,EAAQ;AAChB,UAAM;AAACQ,MAAAA;AAAD,QAAUR,KAAhB;AACA,QAAIQ,KAAK,IAAIA,KAAK,CAACC,cAAN,EAAb,EAAqC,OAAO,KAAKC,SAAL,CAAeV,KAAf,CAAP;AACrC,UAAMW,YAAY,GAAG,KAAKN,SAAL,CAAeL,KAAf,CAArB;AACA,UAAMY,WAAW,GAAG,KAAKvB,OAAL,IAAgB,OAAO,KAAKE,UAAZ,KAA2B5E,aAA3C,GAClB,KAAK4E,UAAL,CAAgBoB,YAAhB,CADkB,GACc,IADlC;AAEA,WAAOC,WAAW,IAChB,KAAK1B,GAAL,CAAS2B,YAAT,CAAsBF,YAAtB,EAAoCH,KAApC,CADK,IAEL,KAAKtB,GAAL,CAAS4B,mBAAT,CAA6BN,KAA7B,CAFF;AAGD;;AAEDf,EAAAA,WAAW,CAAC7C,IAAD,EAAO;AAChB,QAAI,CAAC,KAAKyC,OAAV,EAAmB,OAAO,EAAP;AACnB,UAAMK,KAAK,GAAG,EAAd;AACA,UAAMqB,YAAY,GAAGnE,IAAI,CAACoE,QAAL,CAAc7G,WAAd,IAA6BtB,MAAM,CAACoI,MAAP,CAAcrE,IAAd,CAA7B,GAAmD,CAACA,IAAD,CAAxE;AACAmE,IAAAA,YAAY,CAACrF,OAAb,CAAsBkB,IAAD,IAAU;AAC7B8C,MAAAA,KAAK,CAAC9D,IAAN,CAAWtD,OAAO,CAACgI,QAAR,CAAiB,KAAKtB,SAAtB,EAAiCpC,IAAjC,EAAuCsE,KAAvC,CAA6CpH,sBAA7C,CAAX;AACD,KAFD;AAGA,WAAO4F,KAAP;AACD;;AAEDgB,EAAAA,SAAS,CAACV,KAAD,EAAQ;AACf,QAAI,KAAKX,OAAT,EAAkB;AAChB,YAAM8B,UAAU,GAAG,KAAK1B,WAAL,CAAiB,KAAKM,gBAAL,CAAsBC,KAAtB,CAAjB,CAAnB;AACA,UAAIoB,QAAQ,GAAG,KAAf;AACA,WAAKC,aAAL,GAAqB,CAAC,KAAK7B,QAAL,CAAc8B,IAAd,CAAoB5B,KAAD,IAAW;AAClD,eAAOA,KAAK,CAAC1D,KAAN,CAAY,CAACuF,IAAD,EAAOC,CAAP,KAAa;AAC9B,cAAID,IAAI,KAAKhH,QAAb,EAAuB6G,QAAQ,GAAG,IAAX;AACvB,iBAAOA,QAAQ,IAAI,CAACD,UAAU,CAAC,CAAD,CAAV,CAAcK,CAAd,CAAb,IAAiC/I,QAAQ,CAAC8I,IAAD,EAAOJ,UAAU,CAAC,CAAD,CAAV,CAAcK,CAAd,CAAP,EAAyB/G,aAAzB,CAAhD;AACD,SAHM,CAAP;AAID,OALqB,CAAtB;AAMD;;AACD,WAAO,CAAC,KAAK4G,aAAN,IAAuB,KAAKnC,GAAL,CAAS2B,YAAT,CAAsB,KAAKR,SAAL,CAAeL,KAAf,CAAtB,EAA6CA,KAAK,CAACQ,KAAnD,CAA9B;AACD;;AAzEe;AA4ElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMiB,SAAN,SAAwBtJ,YAAxB,CAAqC;AACrC;AACAsF,EAAAA,WAAW,CAACiE,KAAD,EAAQ;AACjB;AAEA,UAAMrE,IAAI,GAAG,EAAb;AACA,QAAIqE,KAAJ,EAAW/C,MAAM,CAACgD,MAAP,CAActE,IAAd,EAAoBqE,KAApB,EAJM,CAIsB;;AAEvC;;AACA,SAAKE,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AACA;;AACA,SAAKC,QAAL,GAAgB,IAAID,GAAJ,EAAhB;AACA;;AACA,SAAKE,aAAL,GAAqB,IAAIjE,GAAJ,EAArB;AAEA;;AACA,SAAKkE,UAAL,GAAkB,IAAIH,GAAJ,EAAlB;AAEA;;AACA,SAAKI,aAAL,GAAqB,IAAIJ,GAAJ,EAArB;AAEA,SAAKK,QAAL,GAAgB,IAAIpE,GAAJ,EAAhB;AACA,SAAKqE,MAAL,GAAc,KAAd,CApBiB,CAsBjB;;AACA,QAAI/E,KAAK,CAACC,IAAD,EAAO,YAAP,CAAT,EAA+BA,IAAI,CAAC+E,UAAL,GAAkB,IAAlB;AAC/B,QAAIhF,KAAK,CAACC,IAAD,EAAO,eAAP,CAAT,EAAkCA,IAAI,CAACgF,aAAL,GAAqB,KAArB;AAClC,QAAIjF,KAAK,CAACC,IAAD,EAAO,wBAAP,CAAT,EAA2CA,IAAI,CAACiF,sBAAL,GAA8B,KAA9B;AAC3C,QAAIlF,KAAK,CAACC,IAAD,EAAO,UAAP,CAAT,EAA6BA,IAAI,CAACkF,QAAL,GAAgB,GAAhB;AAC7B,QAAInF,KAAK,CAACC,IAAD,EAAO,gBAAP,CAAT,EAAmCA,IAAI,CAACmF,cAAL,GAAsB,GAAtB;AACnC,QAAIpF,KAAK,CAACC,IAAD,EAAO,iBAAP,CAAT,EAAoCA,IAAI,CAACoF,eAAL,GAAuB,KAAvB;AACpCpF,IAAAA,IAAI,CAACqF,oBAAL,GAA4BrF,IAAI,CAACmF,cAAL,KAAwBnF,IAAI,CAACkF,QAAzD,CA7BiB,CA+BjB;;AACA,QAAInF,KAAK,CAACC,IAAD,EAAO,aAAP,CAAT,EAAgCA,IAAI,CAACsF,WAAL,GAAmB,CAACtF,IAAI,CAACuF,UAAzB,CAhCf,CAkCjB;;AACA,UAAMC,cAAc,GAAG7J,eAAe,CAAC8J,MAAhB,EAAvB;AACA,QAAI,CAACD,cAAL,EAAqBxF,IAAI,CAACsF,WAAL,GAAmB,KAAnB,CApCJ,CAsCjB;AACA;;AACA,QAAIvF,KAAK,CAACC,IAAD,EAAO,YAAP,CAAL,IAA6B,CAACA,IAAI,CAACsF,WAAvC,EAAoD;AAClDtF,MAAAA,IAAI,CAACuF,UAAL,GAAkB7H,OAAlB;AACD,KA1CgB,CA4CjB;;;AACA,QAAGC,MAAH,EAAW;AACTqC,MAAAA,IAAI,CAACuF,UAAL,GAAkB,IAAlB;AACD,KA/CgB,CAiDjB;AACA;;;AACA,UAAMG,OAAO,GAAGC,OAAO,CAACC,GAAR,CAAYC,mBAA5B;;AACA,QAAIH,OAAO,KAAKxF,SAAhB,EAA2B;AACzB,YAAM4F,QAAQ,GAAGJ,OAAO,CAACK,WAAR,EAAjB;;AAEA,UAAID,QAAQ,KAAK,OAAb,IAAwBA,QAAQ,KAAK,GAAzC,EAA8C;AAC5C9F,QAAAA,IAAI,CAACuF,UAAL,GAAkB,KAAlB;AACD,OAFD,MAEO,IAAIO,QAAQ,KAAK,MAAb,IAAuBA,QAAQ,KAAK,GAAxC,EAA6C;AAClD9F,QAAAA,IAAI,CAACuF,UAAL,GAAkB,IAAlB;AACD,OAFM,MAEA;AACLvF,QAAAA,IAAI,CAACuF,UAAL,GAAkB,CAAC,CAACO,QAApB;AACD;AACF;;AACD,UAAME,WAAW,GAAGL,OAAO,CAACC,GAAR,CAAYK,iBAAhC;;AACA,QAAID,WAAJ,EAAiB;AACfhG,MAAAA,IAAI,CAACkF,QAAL,GAAgBgB,MAAM,CAACC,QAAP,CAAgBH,WAAhB,EAA6B,EAA7B,CAAhB;AACD,KAlEgB,CAoEjB;;;AACA,QAAIjG,KAAK,CAACC,IAAD,EAAO,QAAP,CAAT,EAA2BA,IAAI,CAACoG,MAAL,GAAc,CAACpG,IAAI,CAACuF,UAAN,IAAoB,CAACvF,IAAI,CAACsF,WAAxC;AAC3B,QAAItF,IAAI,CAACoG,MAAT,EAAiB,KAAKC,eAAL,GAAuB,IAAI7B,GAAJ,EAAvB;AAEjB,QAAIzE,KAAK,CAACC,IAAD,EAAO,gBAAP,CAAT,EAAmCA,IAAI,CAACwC,cAAL,GAAsB,IAAtB;AAEnC,QAAIzC,KAAK,CAACC,IAAD,EAAO,kBAAP,CAAT,EAAqCA,IAAI,CAACsG,gBAAL,GAAwB,KAAxB;AACrC,QAAItG,IAAI,CAACsG,gBAAL,KAA0B,IAA9B,EAAoCtG,IAAI,CAACsG,gBAAL,GAAwB,EAAxB;AACpC,UAAMC,GAAG,GAAGvG,IAAI,CAACsG,gBAAjB;;AACA,QAAIC,GAAJ,EAAS;AACP,UAAI,CAACA,GAAG,CAACC,kBAAT,EAA6BD,GAAG,CAACC,kBAAJ,GAAyB,IAAzB;AAC7B,UAAI,CAACD,GAAG,CAACE,YAAT,EAAuBF,GAAG,CAACE,YAAJ,GAAmB,GAAnB;AACvB,WAAKC,cAAL,GAAsB,IAAIlC,GAAJ,EAAtB;AACD;;AACD,QAAIxE,IAAI,CAAC2G,OAAT,EAAkB3G,IAAI,CAAC2G,OAAL,GAAe7I,MAAM,CAACkC,IAAI,CAAC2G,OAAN,CAArB;AAElB,QAAIC,UAAU,GAAG,CAAjB;;AACA,SAAKC,UAAL,GAAkB,MAAM;AACtBD,MAAAA,UAAU;;AACV,UAAIA,UAAU,IAAI,KAAKE,WAAvB,EAAoC;AAClC,aAAKD,UAAL,GAAkBrJ,QAAlB;AACA,aAAKuJ,aAAL,GAAqB,IAArB,CAFkC,CAGlC;;AACApB,QAAAA,OAAO,CAACqB,QAAR,CAAiB,MAAM,KAAKC,IAAL,CAAUpL,QAAV,CAAvB;AACD;AACF,KARD;;AASA,SAAKqL,QAAL,GAAgB,CAAC,GAAGC,IAAJ,KAAa,KAAKF,IAAL,CAAU9K,MAAV,EAAkB,GAAGgL,IAArB,CAA7B;;AACA,SAAKJ,aAAL,GAAqB,KAArB;AACA,SAAKK,OAAL,GAAepH,IAAf,CAhGiB,CAkGjB;;AACA,QAAIA,IAAI,CAACsF,WAAT,EAAsB;AACpB,WAAK+B,gBAAL,GAAwB,IAAI1L,eAAJ,CAAoB,IAApB,CAAxB;AACD,KAFD,MAEO;AACL,WAAK2L,cAAL,GAAsB,IAAI5L,aAAJ,CAAkB,IAAlB,CAAtB;AACD,KAvGgB,CAyGjB;;;AACA4F,IAAAA,MAAM,CAACC,MAAP,CAAcvB,IAAd;AACD,GA7GoC,CA+GrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAU,EAAAA,GAAG,CAACjC,MAAD,EAAS8I,QAAT,EAAmBC,SAAnB,EAA8B;AAC/B,UAAM;AAAC9H,MAAAA,GAAD;AAAM0F,MAAAA;AAAN,QAAyB,KAAKgC,OAApC;AACA,SAAKtC,MAAL,GAAc,KAAd;AACA,QAAIpG,KAAK,GAAGF,UAAU,CAACC,MAAD,CAAtB;;AACA,QAAIiB,GAAJ,EAAS;AACPhB,MAAAA,KAAK,GAAGA,KAAK,CAACI,GAAN,CAAWS,IAAD,IAAU;AAC1B,cAAMkI,OAAO,GAAG5H,eAAe,CAACN,IAAD,EAAOG,GAAP,CAA/B,CAD0B,CAG1B;;AACA,YAAI0F,eAAe,IAAI,CAAC7J,MAAM,CAACgE,IAAD,CAA9B,EAAsC;AACpC,iBAAOkI,OAAP;AACD;;AACD,eAAOhM,aAAa,CAACgM,OAAD,CAApB;AACD,OARO,CAAR;AASD,KAd8B,CAgB/B;;;AACA/I,IAAAA,KAAK,GAAGA,KAAK,CAACgJ,MAAN,CAAcnI,IAAD,IAAU;AAC7B,UAAIA,IAAI,CAACF,UAAL,CAAgBtC,IAAhB,CAAJ,EAA2B;AACzB,aAAK2H,aAAL,CAAmBhE,GAAnB,CAAuBnB,IAAI,CAACO,KAAL,CAAW,CAAX,CAAvB;;AACA,eAAO,KAAP;AACD,OAJ4B,CAM7B;;;AACA,WAAK4E,aAAL,CAAmB9D,MAAnB,CAA0BrB,IAA1B;;AACA,WAAKmF,aAAL,CAAmB9D,MAAnB,CAA0BrB,IAAI,GAAGpC,cAAjC,EAR6B,CAU7B;AACA;;;AACA,WAAKwK,YAAL,GAAoBzH,SAApB;AAEA,aAAO,IAAP;AACD,KAfO,CAAR;;AAiBA,QAAI,KAAKkH,OAAL,CAAa9B,WAAb,IAA4B,KAAK+B,gBAArC,EAAuD;AACrD,UAAI,CAAC,KAAKP,WAAV,EAAuB,KAAKA,WAAL,GAAmBpI,KAAK,CAAC4D,MAAzB;AACvB,UAAI,KAAK8E,OAAL,CAAarC,UAAjB,EAA6B,KAAK+B,WAAL,IAAoB,CAApB;AAC7BpI,MAAAA,KAAK,CAACL,OAAN,CAAekB,IAAD,IAAU,KAAK8H,gBAAL,CAAsBO,cAAtB,CAAqCrI,IAArC,CAAxB;AACD,KAJD,MAIO;AACL,UAAI,CAAC,KAAKuH,WAAV,EAAuB,KAAKA,WAAL,GAAmB,CAAnB;AACvB,WAAKA,WAAL,IAAoBpI,KAAK,CAAC4D,MAA1B;AACAuF,MAAAA,OAAO,CAACC,GAAR,CACEpJ,KAAK,CAACI,GAAN,CAAU,MAAMS,IAAN,IAAc;AACtB,cAAMwI,GAAG,GAAG,MAAM,KAAKT,cAAL,CAAoBU,YAApB,CAAiCzI,IAAjC,EAAuC,CAACiI,SAAxC,EAAmD,CAAnD,EAAsD,CAAtD,EAAyDD,QAAzD,CAAlB;AACA,YAAIQ,GAAJ,EAAS,KAAKlB,UAAL;AACT,eAAOkB,GAAP;AACD,OAJD,CADF,EAMEE,IANF,CAMOC,OAAO,IAAI;AAChB,YAAI,KAAKpD,MAAT,EAAiB;AACjBoD,QAAAA,OAAO,CAACR,MAAR,CAAepJ,IAAI,IAAIA,IAAvB,EAA6BD,OAA7B,CAAqCC,IAAI,IAAI;AAC3C,eAAKoC,GAAL,CAASzF,OAAO,CAAC8F,OAAR,CAAgBzC,IAAhB,CAAT,EAAgCrD,OAAO,CAAC+F,QAAR,CAAiBuG,QAAQ,IAAIjJ,IAA7B,CAAhC;AACD,SAFD;AAGD,OAXD;AAYD;;AAED,WAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA6J,EAAAA,OAAO,CAAC1J,MAAD,EAAS;AACd,QAAI,KAAKqG,MAAT,EAAiB,OAAO,IAAP;AACjB,UAAMpG,KAAK,GAAGF,UAAU,CAACC,MAAD,CAAxB;AACA,UAAM;AAACiB,MAAAA;AAAD,QAAQ,KAAK0H,OAAnB;AAEA1I,IAAAA,KAAK,CAACL,OAAN,CAAekB,IAAD,IAAU;AACtB;AACA,UAAI,CAACtE,OAAO,CAAC0E,UAAR,CAAmBJ,IAAnB,CAAD,IAA6B,CAAC,KAAKkF,QAAL,CAAcxD,GAAd,CAAkB1B,IAAlB,CAAlC,EAA2D;AACzD,YAAIG,GAAJ,EAASH,IAAI,GAAGtE,OAAO,CAAC2E,IAAR,CAAaF,GAAb,EAAkBH,IAAlB,CAAP;AACTA,QAAAA,IAAI,GAAGtE,OAAO,CAAC8G,OAAR,CAAgBxC,IAAhB,CAAP;AACD;;AAED,WAAK6I,UAAL,CAAgB7I,IAAhB;;AAEA,WAAKmF,aAAL,CAAmBhE,GAAnB,CAAuBnB,IAAvB;;AACA,UAAI,KAAKgF,QAAL,CAActD,GAAd,CAAkB1B,IAAlB,CAAJ,EAA6B;AAC3B,aAAKmF,aAAL,CAAmBhE,GAAnB,CAAuBnB,IAAI,GAAGpC,cAA9B;AACD,OAZqB,CActB;AACA;;;AACA,WAAKwK,YAAL,GAAoBzH,SAApB;AACD,KAjBD;AAmBA,WAAO,IAAP;AACD;AAED;AACA;AACA;AACA;;;AACAmI,EAAAA,KAAK,GAAG;AACN,QAAI,KAAKvD,MAAT,EAAiB,OAAO,KAAKwD,aAAZ;AACjB,SAAKxD,MAAL,GAAc,IAAd,CAFM,CAIN;;AACA,SAAKyD,kBAAL;AACA,UAAMC,OAAO,GAAG,EAAhB;;AACA,SAAK/D,QAAL,CAAcpG,OAAd,CAAsBoK,UAAU,IAAIA,UAAU,CAACpK,OAAX,CAAmBqK,MAAM,IAAI;AAC/D,YAAMC,OAAO,GAAGD,MAAM,EAAtB;AACA,UAAIC,OAAO,YAAYd,OAAvB,EAAgCW,OAAO,CAACjK,IAAR,CAAaoK,OAAb;AACjC,KAHmC,CAApC;;AAIA,SAAK9D,QAAL,CAAcxG,OAAd,CAAsBuK,MAAM,IAAIA,MAAM,CAACC,OAAP,EAAhC;;AACA,SAAKlB,YAAL,GAAoBzH,SAApB;AACA,SAAK4G,WAAL,GAAmB,CAAnB;AACA,SAAKC,aAAL,GAAqB,KAArB;;AACA,SAAKxC,QAAL,CAAclG,OAAd,CAAsByK,MAAM,IAAIA,MAAM,CAAC1H,OAAP,EAAhC;;AACA,KAAC,SAAD,EAAY,SAAZ,EAAuB,SAAvB,EAAkC,cAAlC,EAAkD,WAAlD,EAA+D/C,OAA/D,CAAuE4B,GAAG,IAAI;AAC5E,WAAM,IAAGA,GAAI,EAAb,EAAgBoB,KAAhB;AACD,KAFD;AAIA,SAAKiH,aAAL,GAAqBE,OAAO,CAAClG,MAAR,GAAiBuF,OAAO,CAACC,GAAR,CAAYU,OAAZ,EAAqBP,IAArB,CAA0B,MAAM/H,SAAhC,CAAjB,GAA8D2H,OAAO,CAAC9F,OAAR,EAAnF;AACA,WAAO,KAAKuG,aAAZ;AACD;AAED;AACA;AACA;AACA;;;AACAS,EAAAA,UAAU,GAAG;AACX,UAAMC,SAAS,GAAG,EAAlB;;AACA,SAAKzE,QAAL,CAAclG,OAAd,CAAsB,CAACsE,KAAD,EAAQtC,GAAR,KAAgB;AACpC,YAAMJ,GAAG,GAAG,KAAKmH,OAAL,CAAa1H,GAAb,GAAmBzE,OAAO,CAACgI,QAAR,CAAiB,KAAKmE,OAAL,CAAa1H,GAA9B,EAAmCW,GAAnC,CAAnB,GAA6DA,GAAzE;AACA2I,MAAAA,SAAS,CAAC/I,GAAG,IAAIjD,OAAR,CAAT,GAA4B2F,KAAK,CAACzB,WAAN,GAAoB+H,IAApB,EAA5B;AACD,KAHD;;AAIA,WAAOD,SAAP;AACD;;AAEDE,EAAAA,WAAW,CAACC,KAAD,EAAQhC,IAAR,EAAc;AACvB,SAAKF,IAAL,CAAU,GAAGE,IAAb;AACA,QAAIgC,KAAK,KAAK/M,QAAd,EAAwB,KAAK6K,IAAL,CAAUrL,MAAV,EAAkB,GAAGuL,IAArB;AACzB,GA9PoC,CAgQrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACW,QAALiC,KAAK,CAACD,KAAD,EAAQ5J,IAAR,EAAc8J,IAAd,EAAoBC,IAApB,EAA0BC,IAA1B,EAAgC;AACzC,QAAI,KAAKzE,MAAT,EAAiB;AAEjB,UAAM9E,IAAI,GAAG,KAAKoH,OAAlB;AACA,QAAI3J,SAAJ,EAAe8B,IAAI,GAAGtE,OAAO,CAACuE,SAAR,CAAkBD,IAAlB,CAAP;AACf,QAAIS,IAAI,CAACN,GAAT,EAAcH,IAAI,GAAGtE,OAAO,CAACgI,QAAR,CAAiBjD,IAAI,CAACN,GAAtB,EAA2BH,IAA3B,CAAP;AACd;;AACA,UAAM4H,IAAI,GAAG,CAACgC,KAAD,EAAQ5J,IAAR,CAAb;AACA,QAAIgK,IAAI,KAAKrJ,SAAb,EAAwBiH,IAAI,CAAC5I,IAAL,CAAU8K,IAAV,EAAgBC,IAAhB,EAAsBC,IAAtB,EAAxB,KACK,IAAID,IAAI,KAAKpJ,SAAb,EAAwBiH,IAAI,CAAC5I,IAAL,CAAU8K,IAAV,EAAgBC,IAAhB,EAAxB,KACA,IAAID,IAAI,KAAKnJ,SAAb,EAAwBiH,IAAI,CAAC5I,IAAL,CAAU8K,IAAV;AAE7B,UAAM9C,GAAG,GAAGvG,IAAI,CAACsG,gBAAjB;AACA,QAAIkD,EAAJ;;AACA,QAAIjD,GAAG,KAAKiD,EAAE,GAAG,KAAK9C,cAAL,CAAoB+C,GAApB,CAAwBlK,IAAxB,CAAV,CAAP,EAAiD;AAC/CiK,MAAAA,EAAE,CAACE,UAAH,GAAgB,IAAIC,IAAJ,EAAhB;AACA,aAAO,IAAP;AACD;;AAED,QAAI3J,IAAI,CAACoG,MAAT,EAAiB;AACf,UAAI+C,KAAK,KAAKnN,SAAd,EAAyB;AACvB,aAAKqK,eAAL,CAAqBuD,GAArB,CAAyBrK,IAAzB,EAA+B4H,IAA/B;;AACA0C,QAAAA,UAAU,CAAC,MAAM;AACf,eAAKxD,eAAL,CAAqBhI,OAArB,CAA6B,CAACsE,KAAD,EAAQpD,IAAR,KAAiB;AAC5C,iBAAK0H,IAAL,CAAU,GAAGtE,KAAb;AACA,iBAAKsE,IAAL,CAAUrL,MAAV,EAAkB,GAAG+G,KAArB;;AACA,iBAAK0D,eAAL,CAAqBzF,MAArB,CAA4BrB,IAA5B;AACD,WAJD;AAKD,SANS,EAMP,OAAOS,IAAI,CAACoG,MAAZ,KAAuB,QAAvB,GAAkCpG,IAAI,CAACoG,MAAvC,GAAgD,GANzC,CAAV;AAOA,eAAO,IAAP;AACD;;AACD,UAAI+C,KAAK,KAAKrN,MAAV,IAAoB,KAAKuK,eAAL,CAAqBpF,GAArB,CAAyB1B,IAAzB,CAAxB,EAAwD;AACtD4J,QAAAA,KAAK,GAAGhC,IAAI,CAAC,CAAD,CAAJ,GAAUpL,SAAlB;;AACA,aAAKsK,eAAL,CAAqBzF,MAArB,CAA4BrB,IAA5B;AACD;AACF;;AAED,QAAIgH,GAAG,KAAK4C,KAAK,KAAKrN,MAAV,IAAoBqN,KAAK,KAAKpN,SAAnC,CAAH,IAAoD,KAAKgL,aAA7D,EAA4E;AAC1E,YAAM+C,OAAO,GAAG,CAAChJ,GAAD,EAAMqC,KAAN,KAAgB;AAC9B,YAAIrC,GAAJ,EAAS;AACPqI,UAAAA,KAAK,GAAGhC,IAAI,CAAC,CAAD,CAAJ,GAAU/K,QAAlB;AACA+K,UAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUrG,GAAV;AACA,eAAKoI,WAAL,CAAiBC,KAAjB,EAAwBhC,IAAxB;AACD,SAJD,MAIO,IAAIhE,KAAJ,EAAW;AAChB;AACA,cAAIgE,IAAI,CAAC7E,MAAL,GAAc,CAAlB,EAAqB;AACnB6E,YAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUhE,KAAV;AACD,WAFD,MAEO;AACLgE,YAAAA,IAAI,CAAC5I,IAAL,CAAU4E,KAAV;AACD;;AACD,eAAK+F,WAAL,CAAiBC,KAAjB,EAAwBhC,IAAxB;AACD;AACF,OAdD;;AAgBA,WAAK4C,iBAAL,CAAuBxK,IAAvB,EAA6BgH,GAAG,CAACC,kBAAjC,EAAqD2C,KAArD,EAA4DW,OAA5D;;AACA,aAAO,IAAP;AACD;;AAED,QAAIX,KAAK,KAAKpN,SAAd,EAAyB;AACvB,YAAMiO,WAAW,GAAG,CAAC,KAAKC,SAAL,CAAelO,SAAf,EAA0BwD,IAA1B,EAAgC,EAAhC,CAArB;AACA,UAAIyK,WAAJ,EAAiB,OAAO,IAAP;AAClB;;AAED,QAAIhK,IAAI,CAACkK,UAAL,IAAmBb,IAAI,KAAKnJ,SAA5B,KACDiJ,KAAK,KAAKrN,MAAV,IAAoBqN,KAAK,KAAKlN,UAA9B,IAA4CkN,KAAK,KAAKpN,SADrD,CAAJ,EAEE;AACA,YAAMgH,QAAQ,GAAG/C,IAAI,CAACN,GAAL,GAAWzE,OAAO,CAAC2E,IAAR,CAAaI,IAAI,CAACN,GAAlB,EAAuBH,IAAvB,CAAX,GAA0CA,IAA3D;AACA,UAAI4D,KAAJ;;AACA,UAAI;AACFA,QAAAA,KAAK,GAAG,MAAMvF,IAAI,CAACmF,QAAD,CAAlB;AACD,OAFD,CAEE,OAAOjC,GAAP,EAAY,CAAE,CALhB,CAMA;;;AACA,UAAI,CAACqC,KAAD,IAAU,KAAK2B,MAAnB,EAA2B;AAC3BqC,MAAAA,IAAI,CAAC5I,IAAL,CAAU4E,KAAV;AACD;;AACD,SAAK+F,WAAL,CAAiBC,KAAjB,EAAwBhC,IAAxB;AAEA,WAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACAgD,EAAAA,YAAY,CAACC,KAAD,EAAQ;AAClB,UAAMC,IAAI,GAAGD,KAAK,IAAIA,KAAK,CAACC,IAA5B;;AACA,QAAID,KAAK,IAAIC,IAAI,KAAK,QAAlB,IAA8BA,IAAI,KAAK,SAAvC,KACD,CAAC,KAAKjD,OAAL,CAAanC,sBAAd,IAAyCoF,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,QADrE,CAAJ,EAEE;AACA,WAAKpD,IAAL,CAAU7K,QAAV,EAAoBgO,KAApB;AACD;;AACD,WAAOA,KAAK,IAAI,KAAKtF,MAArB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAmF,EAAAA,SAAS,CAACK,UAAD,EAAa/K,IAAb,EAAmBgL,OAAnB,EAA4B;AACnC,QAAI,CAAC,KAAK5F,UAAL,CAAgB1D,GAAhB,CAAoBqJ,UAApB,CAAL,EAAsC;AACpC,WAAK3F,UAAL,CAAgBiF,GAAhB,CAAoBU,UAApB,EAAgC,IAAI9F,GAAJ,EAAhC;AACD;AAED;;;AACA,UAAMgG,MAAM,GAAG,KAAK7F,UAAL,CAAgB8E,GAAhB,CAAoBa,UAApB,CAAf;AACA;;;AACA,UAAMG,UAAU,GAAGD,MAAM,CAACf,GAAP,CAAWlK,IAAX,CAAnB;;AAEA,QAAIkL,UAAJ,EAAgB;AACdA,MAAAA,UAAU,CAACC,KAAX;AACA,aAAO,KAAP;AACD;;AAED,QAAIC,aAAJ;;AACA,UAAMtJ,KAAK,GAAG,MAAM;AAClB,YAAM/C,IAAI,GAAGkM,MAAM,CAACf,GAAP,CAAWlK,IAAX,CAAb;AACA,YAAMmL,KAAK,GAAGpM,IAAI,GAAGA,IAAI,CAACoM,KAAR,GAAgB,CAAlC;AACAF,MAAAA,MAAM,CAAC5J,MAAP,CAAcrB,IAAd;AACAqL,MAAAA,YAAY,CAACD,aAAD,CAAZ;AACA,UAAIrM,IAAJ,EAAUsM,YAAY,CAACtM,IAAI,CAACqM,aAAN,CAAZ;AACV,aAAOD,KAAP;AACD,KAPD;;AAQAC,IAAAA,aAAa,GAAGd,UAAU,CAACxI,KAAD,EAAQkJ,OAAR,CAA1B;AACA,UAAMM,GAAG,GAAG;AAACF,MAAAA,aAAD;AAAgBtJ,MAAAA,KAAhB;AAAuBqJ,MAAAA,KAAK,EAAE;AAA9B,KAAZ;AACAF,IAAAA,MAAM,CAACZ,GAAP,CAAWrK,IAAX,EAAiBsL,GAAjB;AACA,WAAOA,GAAP;AACD;;AAEDC,EAAAA,eAAe,GAAG;AAChB,WAAO,KAAKhE,WAAL,EAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAiD,EAAAA,iBAAiB,CAACxK,IAAD,EAAOwL,SAAP,EAAkB5B,KAAlB,EAAyBW,OAAzB,EAAkC;AACjD,QAAIkB,cAAJ;AAEA,QAAIjI,QAAQ,GAAGxD,IAAf;;AACA,QAAI,KAAK6H,OAAL,CAAa1H,GAAb,IAAoB,CAACzE,OAAO,CAAC0E,UAAR,CAAmBJ,IAAnB,CAAzB,EAAmD;AACjDwD,MAAAA,QAAQ,GAAG9H,OAAO,CAAC2E,IAAR,CAAa,KAAKwH,OAAL,CAAa1H,GAA1B,EAA+BH,IAA/B,CAAX;AACD;;AAED,UAAM0L,GAAG,GAAG,IAAItB,IAAJ,EAAZ;;AAEA,UAAMrD,gBAAgB,GAAI4E,QAAD,IAAc;AACrClQ,MAAAA,EAAE,CAAC4C,IAAH,CAAQmF,QAAR,EAAkB,CAACjC,GAAD,EAAMqK,OAAN,KAAkB;AAClC,YAAIrK,GAAG,IAAI,CAAC,KAAK4F,cAAL,CAAoBzF,GAApB,CAAwB1B,IAAxB,CAAZ,EAA2C;AACzC,cAAIuB,GAAG,IAAIA,GAAG,CAACuJ,IAAJ,KAAa,QAAxB,EAAkCP,OAAO,CAAChJ,GAAD,CAAP;AAClC;AACD;;AAED,cAAMmK,GAAG,GAAG/E,MAAM,CAAC,IAAIyD,IAAJ,EAAD,CAAlB;;AAEA,YAAIuB,QAAQ,IAAIC,OAAO,CAACtK,IAAR,KAAiBqK,QAAQ,CAACrK,IAA1C,EAAgD;AAC9C,eAAK6F,cAAL,CAAoB+C,GAApB,CAAwBlK,IAAxB,EAA8BmK,UAA9B,GAA2CuB,GAA3C;AACD;;AACD,cAAMzB,EAAE,GAAG,KAAK9C,cAAL,CAAoB+C,GAApB,CAAwBlK,IAAxB,CAAX;;AACA,cAAM6L,EAAE,GAAGH,GAAG,GAAGzB,EAAE,CAACE,UAApB;;AAEA,YAAI0B,EAAE,IAAIL,SAAV,EAAqB;AACnB,eAAKrE,cAAL,CAAoB9F,MAApB,CAA2BrB,IAA3B;;AACAuK,UAAAA,OAAO,CAAC5J,SAAD,EAAYiL,OAAZ,CAAP;AACD,SAHD,MAGO;AACLH,UAAAA,cAAc,GAAGnB,UAAU,CACzBvD,gBADyB,EAEzB,KAAKc,OAAL,CAAad,gBAAb,CAA8BG,YAFL,EAGzB0E,OAHyB,CAA3B;AAKD;AACF,OAxBD;AAyBD,KA1BD;;AA4BA,QAAI,CAAC,KAAKzE,cAAL,CAAoBzF,GAApB,CAAwB1B,IAAxB,CAAL,EAAoC;AAClC,WAAKmH,cAAL,CAAoBkD,GAApB,CAAwBrK,IAAxB,EAA8B;AAC5BmK,QAAAA,UAAU,EAAEuB,GADgB;AAE5BI,QAAAA,UAAU,EAAE,MAAM;AAChB,eAAK3E,cAAL,CAAoB9F,MAApB,CAA2BrB,IAA3B;;AACAqL,UAAAA,YAAY,CAACI,cAAD,CAAZ;AACA,iBAAO7B,KAAP;AACD;AAN2B,OAA9B;;AAQA6B,MAAAA,cAAc,GAAGnB,UAAU,CACzBvD,gBADyB,EAEzB,KAAKc,OAAL,CAAad,gBAAb,CAA8BG,YAFL,CAA3B;AAID;AACF;;AAED6E,EAAAA,eAAe,GAAG;AAChB,WAAO,CAAC,GAAG,KAAK5G,aAAL,CAAmBvD,MAAnB,EAAJ,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAoK,EAAAA,UAAU,CAAChM,IAAD,EAAO4D,KAAP,EAAc;AACtB,QAAI,KAAKiE,OAAL,CAAahB,MAAb,IAAuB1J,MAAM,CAAC8O,IAAP,CAAYjM,IAAZ,CAA3B,EAA8C,OAAO,IAAP;;AAC9C,QAAI,CAAC,KAAKoI,YAAV,EAAwB;AACtB,YAAM;AAACjI,QAAAA;AAAD,UAAQ,KAAK0H,OAAnB;AACA,YAAMqE,GAAG,GAAG,KAAKrE,OAAL,CAAaT,OAAzB;AAEA,YAAMA,OAAO,GAAG8E,GAAG,IAAIA,GAAG,CAAC3M,GAAJ,CAAQW,gBAAgB,CAACC,GAAD,CAAxB,CAAvB;AACA,YAAMhB,KAAK,GAAGZ,MAAM,CAAC6I,OAAD,CAAN,CACXe,MADW,CACHnI,IAAD,IAAU,OAAOA,IAAP,KAAgBlC,WAAhB,IAA+B,CAAC9B,MAAM,CAACgE,IAAD,CAD5C,EAEXT,GAFW,CAENS,IAAD,IAAUA,IAAI,GAAGpC,cAFV,CAAd;;AAGA,YAAMgB,IAAI,GAAG,KAAKmN,eAAL,GAAuBxM,GAAvB,CAA2BW,gBAAgB,CAACC,GAAD,CAA3C,EAAkDgM,MAAlD,CAAyD/E,OAAzD,EAAkEjI,KAAlE,CAAb;;AACA,WAAKiJ,YAAL,GAAoBvM,QAAQ,CAAC+C,IAAD,EAAO+B,SAAP,EAAkB9C,aAAlB,CAA5B;AACD;;AAED,WAAO,KAAKuK,YAAL,CAAkB,CAACpI,IAAD,EAAO4D,KAAP,CAAlB,CAAP;AACD;;AAEDK,EAAAA,YAAY,CAACjE,IAAD,EAAO3B,IAAP,EAAa;AACvB,WAAO,CAAC,KAAK2N,UAAL,CAAgBhM,IAAhB,EAAsB3B,IAAtB,CAAR;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA+N,EAAAA,gBAAgB,CAACpM,IAAD,EAAOqM,KAAP,EAAc;AAC5B,UAAMjK,SAAS,GAAGiK,KAAK,IAAI,KAAKxE,OAAL,CAAahC,eAAtB,IAAyC,CAAC7J,MAAM,CAACgE,IAAD,CAAhD,GAAyDA,IAAzD,GAAgEjE,UAAU,CAACiE,IAAD,CAA5F;AACA,UAAMqC,MAAM,GAAG,KAAKwF,OAAL,CAAa5E,cAA5B;AAEA,WAAO,IAAId,WAAJ,CAAgBnC,IAAhB,EAAsBoC,SAAtB,EAAiCC,MAAjC,EAAyC,IAAzC,CAAP;AACD,GA7foC,CA+frC;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACAiK,EAAAA,cAAc,CAACC,SAAD,EAAY;AACxB,QAAI,CAAC,KAAKC,YAAV,EAAwB,KAAKA,YAAL,GAAoB,KAAKC,OAAL,CAAaC,IAAb,CAAkB,IAAlB,CAApB;AACxB,UAAM5L,GAAG,GAAGpF,OAAO,CAAC8G,OAAR,CAAgB+J,SAAhB,CAAZ;AACA,QAAI,CAAC,KAAKvH,QAAL,CAActD,GAAd,CAAkBZ,GAAlB,CAAL,EAA6B,KAAKkE,QAAL,CAAcqF,GAAd,CAAkBvJ,GAAlB,EAAuB,IAAIF,QAAJ,CAAaE,GAAb,EAAkB,KAAK0L,YAAvB,CAAvB;AAC7B,WAAO,KAAKxH,QAAL,CAAckF,GAAd,CAAkBpJ,GAAlB,CAAP;AACD,GA5gBoC,CA8gBrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAoD,EAAAA,mBAAmB,CAACN,KAAD,EAAQ;AACzB,QAAI,KAAKiE,OAAL,CAAanC,sBAAjB,EAAyC,OAAO,IAAP,CADhB,CAGzB;;AACA,UAAMiH,EAAE,GAAG/I,KAAK,IAAI+C,MAAM,CAACC,QAAP,CAAgBhD,KAAK,CAACgJ,IAAtB,EAA4B,EAA5B,CAApB;AACA,UAAMC,EAAE,GAAGF,EAAE,GAAG,KAAhB;AACA,UAAMG,EAAE,GAAGnG,MAAM,CAACC,QAAP,CAAgBiG,EAAE,CAACE,QAAH,CAAY,CAAZ,EAAe,CAAf,CAAhB,EAAmC,EAAnC,CAAX;AACA,WAAOC,OAAO,CAAC,IAAIF,EAAL,CAAd;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAL,EAAAA,OAAO,CAACF,SAAD,EAAYxN,IAAZ,EAAkBkO,WAAlB,EAA+B;AACpC;AACA;AACA;AACA,UAAMjN,IAAI,GAAGtE,OAAO,CAAC2E,IAAR,CAAakM,SAAb,EAAwBxN,IAAxB,CAAb;AACA,UAAMyE,QAAQ,GAAG9H,OAAO,CAAC8G,OAAR,CAAgBxC,IAAhB,CAAjB;AACAiN,IAAAA,WAAW,GAAGA,WAAW,IAAI,IAAf,GACVA,WADU,GAEV,KAAKjI,QAAL,CAActD,GAAd,CAAkB1B,IAAlB,KAA2B,KAAKgF,QAAL,CAActD,GAAd,CAAkB8B,QAAlB,CAF/B,CANoC,CAUpC;AACA;;AACA,QAAI,CAAC,KAAKkH,SAAL,CAAe,QAAf,EAAyB1K,IAAzB,EAA+B,GAA/B,CAAL,EAA0C,OAZN,CAcpC;;AACA,QAAI,CAACiN,WAAD,IAAgB,CAAC,KAAKpF,OAAL,CAAa9B,WAA9B,IAA6C,KAAKf,QAAL,CAAc1D,IAAd,KAAuB,CAAxE,EAA2E;AACzE,WAAKH,GAAL,CAASoL,SAAT,EAAoBxN,IAApB,EAA0B,IAA1B;AACD,KAjBmC,CAmBpC;AACA;;;AACA,UAAMmO,EAAE,GAAG,KAAKZ,cAAL,CAAoBtM,IAApB,CAAX;;AACA,UAAMmN,uBAAuB,GAAGD,EAAE,CAACvL,WAAH,EAAhC,CAtBoC,CAwBpC;;AACAwL,IAAAA,uBAAuB,CAACrO,OAAxB,CAAgCsO,MAAM,IAAI,KAAKX,OAAL,CAAazM,IAAb,EAAmBoN,MAAnB,CAA1C,EAzBoC,CA2BpC;;AACA,UAAMC,MAAM,GAAG,KAAKf,cAAL,CAAoBC,SAApB,CAAf;;AACA,UAAMe,UAAU,GAAGD,MAAM,CAAC3L,GAAP,CAAW3C,IAAX,CAAnB;AACAsO,IAAAA,MAAM,CAACjM,MAAP,CAAcrC,IAAd,EA9BoC,CAgCpC;AACA;AACA;AACA;AACA;;AACA,QAAI,KAAKsG,aAAL,CAAmB3D,GAAnB,CAAuB8B,QAAvB,CAAJ,EAAsC;AACpC,WAAK6B,aAAL,CAAmBhE,MAAnB,CAA0BmC,QAA1B;AACD,KAvCmC,CAyCpC;;;AACA,QAAI+J,OAAO,GAAGvN,IAAd;AACA,QAAI,KAAK6H,OAAL,CAAa1H,GAAjB,EAAsBoN,OAAO,GAAG7R,OAAO,CAACgI,QAAR,CAAiB,KAAKmE,OAAL,CAAa1H,GAA9B,EAAmCH,IAAnC,CAAV;;AACtB,QAAI,KAAK6H,OAAL,CAAad,gBAAb,IAAiC,KAAKI,cAAL,CAAoBzF,GAApB,CAAwB6L,OAAxB,CAArC,EAAuE;AACrE,YAAM3D,KAAK,GAAG,KAAKzC,cAAL,CAAoB+C,GAApB,CAAwBqD,OAAxB,EAAiCzB,UAAjC,EAAd;;AACA,UAAIlC,KAAK,KAAKrN,MAAd,EAAsB;AACvB,KA/CmC,CAiDpC;AACA;;;AACA,SAAKyI,QAAL,CAAc3D,MAAd,CAAqBrB,IAArB;;AACA,SAAKgF,QAAL,CAAc3D,MAAd,CAAqBmC,QAArB;;AACA,UAAMgK,SAAS,GAAGP,WAAW,GAAGtQ,aAAH,GAAmBF,SAAhD;AACA,QAAI6Q,UAAU,IAAI,CAAC,KAAKtB,UAAL,CAAgBhM,IAAhB,CAAnB,EAA0C,KAAK6J,KAAL,CAAW2D,SAAX,EAAsBxN,IAAtB,EAtDN,CAwDpC;;AACA,QAAI,CAAC,KAAK6H,OAAL,CAAa9B,WAAlB,EAA+B;AAC7B,WAAK8C,UAAL,CAAgB7I,IAAhB;AACD;AACF;AAED;AACA;AACA;AACA;;;AACA6I,EAAAA,UAAU,CAAC7I,IAAD,EAAO;AACf,SAAKyN,UAAL,CAAgBzN,IAAhB;;AACA,UAAMc,GAAG,GAAGpF,OAAO,CAAC8F,OAAR,CAAgBxB,IAAhB,CAAZ;;AACA,SAAKsM,cAAL,CAAoBxL,GAApB,EAAyBM,MAAzB,CAAgC1F,OAAO,CAAC+F,QAAR,CAAiBzB,IAAjB,CAAhC;AACD;AAED;AACA;AACA;AACA;;;AACAyN,EAAAA,UAAU,CAACzN,IAAD,EAAO;AACf,UAAMiJ,OAAO,GAAG,KAAK/D,QAAL,CAAcgF,GAAd,CAAkBlK,IAAlB,CAAhB;;AACA,QAAI,CAACiJ,OAAL,EAAc;AACdA,IAAAA,OAAO,CAACnK,OAAR,CAAgBqK,MAAM,IAAIA,MAAM,EAAhC;;AACA,SAAKjE,QAAL,CAAc7D,MAAd,CAAqBrB,IAArB;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA0N,EAAAA,cAAc,CAAC1N,IAAD,EAAOmJ,MAAP,EAAe;AAC3B,QAAI,CAACA,MAAL,EAAa;;AACb,QAAIvK,IAAI,GAAG,KAAKsG,QAAL,CAAcgF,GAAd,CAAkBlK,IAAlB,CAAX;;AACA,QAAI,CAACpB,IAAL,EAAW;AACTA,MAAAA,IAAI,GAAG,EAAP;;AACA,WAAKsG,QAAL,CAAcmF,GAAd,CAAkBrK,IAAlB,EAAwBpB,IAAxB;AACD;;AACDA,IAAAA,IAAI,CAACI,IAAL,CAAUmK,MAAV;AACD;;AAEDwE,EAAAA,SAAS,CAACC,IAAD,EAAOnN,IAAP,EAAa;AACpB,QAAI,KAAK8E,MAAT,EAAiB;AACjB,UAAMsC,OAAO,GAAG;AAACgG,MAAAA,IAAI,EAAExR,MAAP;AAAesO,MAAAA,UAAU,EAAE,IAA3B;AAAiCmD,MAAAA,KAAK,EAAE,IAAxC;AAA8C,SAAGrN;AAAjD,KAAhB;AACA,QAAI4I,MAAM,GAAGzN,QAAQ,CAACgS,IAAD,EAAO/F,OAAP,CAArB;;AACA,SAAKvC,QAAL,CAAcnE,GAAd,CAAkBkI,MAAlB;;AACAA,IAAAA,MAAM,CAAC0E,IAAP,CAAYjR,SAAZ,EAAuB,MAAM;AAC3BuM,MAAAA,MAAM,GAAG1I,SAAT;AACD,KAFD;AAGA0I,IAAAA,MAAM,CAAC0E,IAAP,CAAYhR,OAAZ,EAAqB,MAAM;AACzB,UAAIsM,MAAJ,EAAY;AACV,aAAK/D,QAAL,CAAcjE,MAAd,CAAqBgI,MAArB;;AACAA,QAAAA,MAAM,GAAG1I,SAAT;AACD;AACF,KALD;AAMA,WAAO0I,MAAP;AACD;;AA1pBoC,C,CA8pBrC;;;AACA2E,OAAO,CAACnJ,SAAR,GAAoBA,SAApB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMoJ,KAAK,GAAG,CAAC9O,KAAD,EAAQ0I,OAAR,KAAoB;AAChC,QAAMqG,OAAO,GAAG,IAAIrJ,SAAJ,CAAcgD,OAAd,CAAhB;AACAqG,EAAAA,OAAO,CAAC/M,GAAR,CAAYhC,KAAZ;AACA,SAAO+O,OAAP;AACD,CAJD;;AAMAF,OAAO,CAACC,KAAR,GAAgBA,KAAhB","sourcesContent":["'use strict';\n\nconst { EventEmitter } = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You’re frozen when your heart’s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path)\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n"]},"metadata":{},"sourceType":"script"}
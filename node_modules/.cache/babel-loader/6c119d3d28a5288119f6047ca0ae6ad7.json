{"ast":null,"code":"const path = require('path');\n\nconst fs = require('fs');\n\nconst existsSync = fs.existsSync;\n\nconst utils = require('../utils');\n\nmodule.exports = exec;\nmodule.exports.expandScript = expandScript;\n/**\n * Reads the cwd/package.json file and looks to see if it can load a script\n * and possibly an exec first from package.main, then package.start.\n *\n * @return {Object} exec & script if found\n */\n\nfunction execFromPackage() {\n  // doing a try/catch because we can't use the path.exist callback pattern\n  // or we could, but the code would get messy, so this will do exactly\n  // what we're after - if the file doesn't exist, it'll throw.\n  try {\n    // note: this isn't nodemon's package, it's the user's cwd package\n    var pkg = require(path.join(process.cwd(), 'package.json'));\n\n    if (pkg.main !== undefined) {\n      // no app found to run - so give them a tip and get the feck out\n      return {\n        exec: null,\n        script: pkg.main\n      };\n    }\n\n    if (pkg.scripts && pkg.scripts.start) {\n      return {\n        exec: pkg.scripts.start\n      };\n    }\n  } catch (e) {}\n\n  return null;\n}\n\nfunction replace(map, str) {\n  var re = new RegExp('{{(' + Object.keys(map).join('|') + ')}}', 'g');\n  return str.replace(re, function (all, m) {\n    return map[m] || all || '';\n  });\n}\n\nfunction expandScript(script, ext) {\n  if (!ext) {\n    ext = '.js';\n  }\n\n  if (script.indexOf(ext) !== -1) {\n    return script;\n  }\n\n  if (existsSync(path.resolve(script))) {\n    return script;\n  }\n\n  if (existsSync(path.resolve(script + ext))) {\n    return script + ext;\n  }\n\n  return script;\n}\n/**\n * Discovers all the options required to run the script\n * and if a custom exec has been passed in, then it will\n * also try to work out what extensions to monitor and\n * whether there's a special way of running that script.\n *\n * @param  {Object} nodemonOptions\n * @param  {Object} execMap\n * @return {Object} new and updated version of nodemonOptions\n */\n\n\nfunction exec(nodemonOptions, execMap) {\n  if (!execMap) {\n    execMap = {};\n  }\n\n  var options = utils.clone(nodemonOptions || {});\n  var script; // if there's no script passed, try to get it from the first argument\n\n  if (!options.script && (options.args || []).length) {\n    script = expandScript(options.args[0], options.ext && '.' + (options.ext || 'js').split(',')[0]); // if the script was found, shift it off our args\n\n    if (script !== options.args[0]) {\n      options.script = script;\n      options.args.shift();\n    }\n  } // if there's no exec found yet, then try to read it from the local\n  // package.json this logic used to sit in the cli/parse, but actually the cli\n  // should be parsed first, then the user options (via nodemon.json) then\n  // finally default down to pot shots at the directory via package.json\n\n\n  if (!options.exec && !options.script) {\n    var found = execFromPackage();\n\n    if (found !== null) {\n      if (found.exec) {\n        options.exec = found.exec;\n      }\n\n      if (!options.script) {\n        options.script = found.script;\n      }\n\n      if (Array.isArray(options.args) && options.scriptPosition === null) {\n        options.scriptPosition = options.args.length;\n      }\n    }\n  } // var options = utils.clone(nodemonOptions || {});\n\n\n  script = path.basename(options.script || '');\n  var scriptExt = path.extname(script).slice(1);\n  var extension = options.ext;\n\n  if (extension === undefined) {\n    var isJS = scriptExt === 'js' || scriptExt === 'mjs';\n    extension = isJS || !scriptExt ? 'js,mjs' : scriptExt;\n    extension += ',json'; // Always watch JSON files\n  }\n\n  var execDefined = !!options.exec; // allows the user to simplify cli usage:\n  // https://github.com/remy/nodemon/issues/195\n  // but always give preference to the user defined argument\n\n  if (!options.exec && execMap[scriptExt] !== undefined) {\n    options.exec = execMap[scriptExt];\n    execDefined = true;\n  }\n\n  options.execArgs = nodemonOptions.execArgs || [];\n\n  if (Array.isArray(options.exec)) {\n    options.execArgs = options.exec;\n    options.exec = options.execArgs.shift();\n  }\n\n  if (options.exec === undefined) {\n    options.exec = 'node';\n  } else {\n    // allow variable substitution for {{filename}} and {{pwd}}\n    var substitution = replace.bind(null, {\n      filename: options.script,\n      pwd: process.cwd()\n    });\n    var newExec = substitution(options.exec);\n\n    if (newExec !== options.exec && options.exec.indexOf('{{filename}}') !== -1) {\n      options.script = null;\n    }\n\n    options.exec = newExec;\n    var newExecArgs = options.execArgs.map(substitution);\n\n    if (newExecArgs.join('') !== options.execArgs.join('')) {\n      options.execArgs = newExecArgs;\n      delete options.script;\n    }\n  }\n\n  if (options.exec === 'node' && options.nodeArgs && options.nodeArgs.length) {\n    options.execArgs = options.execArgs.concat(options.nodeArgs);\n  } // note: indexOf('coffee') handles both .coffee and .litcoffee\n\n\n  if (!execDefined && options.exec === 'node' && scriptExt.indexOf('coffee') !== -1) {\n    options.exec = 'coffee'; // we need to get execArgs set before the script\n    // for example, in `nodemon --debug my-script.coffee --my-flag`, debug is an\n    // execArg, while my-flag is a script arg\n\n    var leadingArgs = (options.args || []).splice(0, options.scriptPosition);\n    options.execArgs = options.execArgs.concat(leadingArgs);\n    options.scriptPosition = 0;\n\n    if (options.execArgs.length > 0) {\n      // because this is the coffee executable, we need to combine the exec args\n      // into a single argument after the nodejs flag\n      options.execArgs = ['--nodejs', options.execArgs.join(' ')];\n    }\n  }\n\n  if (options.exec === 'coffee') {\n    // don't override user specified extension tracking\n    if (options.ext === undefined) {\n      if (extension) {\n        extension += ',';\n      }\n\n      extension += 'coffee,litcoffee';\n    } // because windows can't find 'coffee', it needs the real file 'coffee.cmd'\n\n\n    if (utils.isWindows) {\n      options.exec += '.cmd';\n    }\n  } // allow users to make a mistake on the extension to monitor\n  // converts .js, pug => js,pug\n  // BIG NOTE: user can't do this: nodemon -e *.js\n  // because the terminal will automatically expand the glob against\n  // the file system :(\n\n\n  extension = (extension.match(/[^,*\\s]+/g) || []).map(ext => ext.replace(/^\\./, '')).join(',');\n  options.ext = extension;\n\n  if (options.script) {\n    options.script = expandScript(options.script, extension && '.' + extension.split(',')[0]);\n  }\n\n  options.env = {}; // make sure it's an object (and since we don't have )\n\n  if ({}.toString.apply(nodemonOptions.env) === '[object Object]') {\n    options.env = utils.clone(nodemonOptions.env);\n  } else if (nodemonOptions.env !== undefined) {\n    throw new Error('nodemon env values must be an object: { PORT: 8000 }');\n  }\n\n  return options;\n}","map":{"version":3,"sources":["/Users/jordanthomson/code/blog-with-Node-React/node_modules/nodemon/lib/config/exec.js"],"names":["path","require","fs","existsSync","utils","module","exports","exec","expandScript","execFromPackage","pkg","join","process","cwd","main","undefined","script","scripts","start","e","replace","map","str","re","RegExp","Object","keys","all","m","ext","indexOf","resolve","nodemonOptions","execMap","options","clone","args","length","split","shift","found","Array","isArray","scriptPosition","basename","scriptExt","extname","slice","extension","isJS","execDefined","execArgs","substitution","bind","filename","pwd","newExec","newExecArgs","nodeArgs","concat","leadingArgs","splice","isWindows","match","env","toString","apply","Error"],"mappings":"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","sourcesContent":["const path = require('path');\nconst fs = require('fs');\nconst existsSync = fs.existsSync;\nconst utils = require('../utils');\n\nmodule.exports = exec;\nmodule.exports.expandScript = expandScript;\n\n/**\n * Reads the cwd/package.json file and looks to see if it can load a script\n * and possibly an exec first from package.main, then package.start.\n *\n * @return {Object} exec & script if found\n */\nfunction execFromPackage() {\n  // doing a try/catch because we can't use the path.exist callback pattern\n  // or we could, but the code would get messy, so this will do exactly\n  // what we're after - if the file doesn't exist, it'll throw.\n  try {\n    // note: this isn't nodemon's package, it's the user's cwd package\n    var pkg = require(path.join(process.cwd(), 'package.json'));\n    if (pkg.main !== undefined) {\n      // no app found to run - so give them a tip and get the feck out\n      return { exec: null, script: pkg.main };\n    }\n\n    if (pkg.scripts && pkg.scripts.start) {\n      return { exec: pkg.scripts.start };\n    }\n  } catch (e) { }\n\n  return null;\n}\n\nfunction replace(map, str) {\n  var re = new RegExp('{{(' + Object.keys(map).join('|') + ')}}', 'g');\n  return str.replace(re, function (all, m) {\n    return map[m] || all || '';\n  });\n}\n\nfunction expandScript(script, ext) {\n  if (!ext) {\n    ext = '.js';\n  }\n  if (script.indexOf(ext) !== -1) {\n    return script;\n  }\n\n  if (existsSync(path.resolve(script))) {\n    return script;\n  }\n\n  if (existsSync(path.resolve(script + ext))) {\n    return script + ext;\n  }\n\n  return script;\n}\n\n/**\n * Discovers all the options required to run the script\n * and if a custom exec has been passed in, then it will\n * also try to work out what extensions to monitor and\n * whether there's a special way of running that script.\n *\n * @param  {Object} nodemonOptions\n * @param  {Object} execMap\n * @return {Object} new and updated version of nodemonOptions\n */\nfunction exec(nodemonOptions, execMap) {\n  if (!execMap) {\n    execMap = {};\n  }\n\n  var options = utils.clone(nodemonOptions || {});\n  var script;\n\n  // if there's no script passed, try to get it from the first argument\n  if (!options.script && (options.args || []).length) {\n    script = expandScript(options.args[0],\n      options.ext && ('.' + (options.ext || 'js').split(',')[0]));\n\n    // if the script was found, shift it off our args\n    if (script !== options.args[0]) {\n      options.script = script;\n      options.args.shift();\n    }\n  }\n\n  // if there's no exec found yet, then try to read it from the local\n  // package.json this logic used to sit in the cli/parse, but actually the cli\n  // should be parsed first, then the user options (via nodemon.json) then\n  // finally default down to pot shots at the directory via package.json\n  if (!options.exec && !options.script) {\n    var found = execFromPackage();\n    if (found !== null) {\n      if (found.exec) {\n        options.exec = found.exec;\n      }\n      if (!options.script) {\n        options.script = found.script;\n      }\n      if (Array.isArray(options.args) &&\n        options.scriptPosition === null) {\n        options.scriptPosition = options.args.length;\n      }\n    }\n  }\n\n  // var options = utils.clone(nodemonOptions || {});\n  script = path.basename(options.script || '');\n\n  var scriptExt = path.extname(script).slice(1);\n\n  var extension = options.ext;\n  if (extension === undefined) {\n    var isJS = scriptExt === 'js' || scriptExt === 'mjs';\n    extension = (isJS || !scriptExt) ? 'js,mjs' : scriptExt;\n    extension += ',json'; // Always watch JSON files\n  }\n\n  var execDefined = !!options.exec;\n\n  // allows the user to simplify cli usage:\n  // https://github.com/remy/nodemon/issues/195\n  // but always give preference to the user defined argument\n  if (!options.exec && execMap[scriptExt] !== undefined) {\n    options.exec = execMap[scriptExt];\n    execDefined = true;\n  }\n\n  options.execArgs = nodemonOptions.execArgs || [];\n\n  if (Array.isArray(options.exec)) {\n    options.execArgs = options.exec;\n    options.exec = options.execArgs.shift();\n  }\n\n  if (options.exec === undefined) {\n    options.exec = 'node';\n  } else {\n    // allow variable substitution for {{filename}} and {{pwd}}\n    var substitution = replace.bind(null, {\n      filename: options.script,\n      pwd: process.cwd(),\n    });\n\n    var newExec = substitution(options.exec);\n    if (newExec !== options.exec &&\n      options.exec.indexOf('{{filename}}') !== -1) {\n      options.script = null;\n    }\n    options.exec = newExec;\n\n    var newExecArgs = options.execArgs.map(substitution);\n    if (newExecArgs.join('') !== options.execArgs.join('')) {\n      options.execArgs = newExecArgs;\n      delete options.script;\n    }\n  }\n\n\n  if (options.exec === 'node' && options.nodeArgs && options.nodeArgs.length) {\n    options.execArgs = options.execArgs.concat(options.nodeArgs);\n  }\n\n  // note: indexOf('coffee') handles both .coffee and .litcoffee\n  if (!execDefined && options.exec === 'node' &&\n    scriptExt.indexOf('coffee') !== -1) {\n    options.exec = 'coffee';\n\n    // we need to get execArgs set before the script\n    // for example, in `nodemon --debug my-script.coffee --my-flag`, debug is an\n    // execArg, while my-flag is a script arg\n    var leadingArgs = (options.args || []).splice(0, options.scriptPosition);\n    options.execArgs = options.execArgs.concat(leadingArgs);\n    options.scriptPosition = 0;\n\n    if (options.execArgs.length > 0) {\n      // because this is the coffee executable, we need to combine the exec args\n      // into a single argument after the nodejs flag\n      options.execArgs = ['--nodejs', options.execArgs.join(' ')];\n    }\n  }\n\n  if (options.exec === 'coffee') {\n    // don't override user specified extension tracking\n    if (options.ext === undefined) {\n      if (extension) { extension += ','; }\n      extension += 'coffee,litcoffee';\n    }\n\n    // because windows can't find 'coffee', it needs the real file 'coffee.cmd'\n    if (utils.isWindows) {\n      options.exec += '.cmd';\n    }\n  }\n\n  // allow users to make a mistake on the extension to monitor\n  // converts .js, pug => js,pug\n  // BIG NOTE: user can't do this: nodemon -e *.js\n  // because the terminal will automatically expand the glob against\n  // the file system :(\n  extension = (extension.match(/[^,*\\s]+/g) || [])\n    .map(ext => ext.replace(/^\\./, ''))\n    .join(',');\n\n  options.ext = extension;\n\n  if (options.script) {\n    options.script = expandScript(options.script,\n      extension && ('.' + extension.split(',')[0]));\n  }\n\n  options.env = {};\n  // make sure it's an object (and since we don't have )\n  if (({}).toString.apply(nodemonOptions.env) === '[object Object]') {\n    options.env = utils.clone(nodemonOptions.env);\n  } else if (nodemonOptions.env !== undefined) {\n    throw new Error('nodemon env values must be an object: { PORT: 8000 }');\n  }\n\n  return options;\n}\n"]},"metadata":{},"sourceType":"script"}
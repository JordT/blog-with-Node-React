{"ast":null,"code":"const minimatch = require('minimatch');\n\nconst path = require('path');\n\nconst fs = require('fs');\n\nconst debug = require('debug')('nodemon:match');\n\nconst utils = require('../utils');\n\nmodule.exports = match;\nmodule.exports.rulesToMonitor = rulesToMonitor;\n\nfunction rulesToMonitor(watch, ignore, config) {\n  var monitor = [];\n\n  if (!Array.isArray(ignore)) {\n    if (ignore) {\n      ignore = [ignore];\n    } else {\n      ignore = [];\n    }\n  }\n\n  if (!Array.isArray(watch)) {\n    if (watch) {\n      watch = [watch];\n    } else {\n      watch = [];\n    }\n  }\n\n  if (watch && watch.length) {\n    monitor = utils.clone(watch);\n  }\n\n  if (ignore) {\n    [].push.apply(monitor, (ignore || []).map(function (rule) {\n      return '!' + rule;\n    }));\n  }\n\n  var cwd = process.cwd(); // next check if the monitored paths are actual directories\n  // or just patterns - and expand the rule to include *.*\n\n  monitor = monitor.map(function (rule) {\n    var not = rule.slice(0, 1) === '!';\n\n    if (not) {\n      rule = rule.slice(1);\n    }\n\n    if (rule === '.' || rule === '.*') {\n      rule = '*.*';\n    }\n\n    var dir = path.resolve(cwd, rule);\n\n    try {\n      var stat = fs.statSync(dir);\n\n      if (stat.isDirectory()) {\n        rule = dir;\n\n        if (rule.slice(-1) !== '/') {\n          rule += '/';\n        }\n\n        rule += '**/*'; // `!not` ... sorry.\n\n        if (!not) {\n          config.dirs.push(dir);\n        }\n      } else {\n        // ensures we end up in the check that tries to get a base directory\n        // and then adds it to the watch list\n        throw new Error();\n      }\n    } catch (e) {\n      var base = tryBaseDir(dir);\n\n      if (!not && base) {\n        if (config.dirs.indexOf(base) === -1) {\n          config.dirs.push(base);\n        }\n      }\n    }\n\n    if (rule.slice(-1) === '/') {\n      // just slap on a * anyway\n      rule += '*';\n    } // if the url ends with * but not **/* and not *.*\n    // then convert to **/* - somehow it was missed :-\\\n\n\n    if (rule.slice(-4) !== '**/*' && rule.slice(-1) === '*' && rule.indexOf('*.') === -1) {\n      if (rule.slice(-2) !== '**') {\n        rule += '*/*';\n      }\n    }\n\n    return (not ? '!' : '') + rule;\n  });\n  return monitor;\n}\n\nfunction tryBaseDir(dir) {\n  var stat;\n\n  if (/[?*\\{\\[]+/.test(dir)) {\n    // if this is pattern, then try to find the base\n    try {\n      var base = path.dirname(dir.replace(/([?*\\{\\[]+.*$)/, 'foo'));\n      stat = fs.statSync(base);\n\n      if (stat.isDirectory()) {\n        return base;\n      }\n    } catch (error) {// console.log(error);\n    }\n  } else {\n    try {\n      stat = fs.statSync(dir); // if this path is actually a single file that exists, then just monitor\n      // that, *specifically*.\n\n      if (stat.isFile() || stat.isDirectory()) {\n        return dir;\n      }\n    } catch (e) {}\n  }\n\n  return false;\n}\n\nfunction match(files, monitor, ext) {\n  // sort the rules by highest specificity (based on number of slashes)\n  // ignore rules (!) get sorted highest as they take precedent\n  const cwd = process.cwd();\n  var rules = monitor.sort(function (a, b) {\n    var r = b.split(path.sep).length - a.split(path.sep).length;\n    var aIsIgnore = a.slice(0, 1) === '!';\n    var bIsIgnore = b.slice(0, 1) === '!';\n\n    if (aIsIgnore || bIsIgnore) {\n      if (aIsIgnore) {\n        return -1;\n      }\n\n      return 1;\n    }\n\n    if (r === 0) {\n      return b.length - a.length;\n    }\n\n    return r;\n  }).map(function (s) {\n    var prefix = s.slice(0, 1);\n\n    if (prefix === '!') {\n      if (s.indexOf('!' + cwd) === 0) {\n        return s;\n      } // if it starts with a period, then let's get the relative path\n\n\n      if (s.indexOf('!.') === 0) {\n        return '!' + path.resolve(cwd, s.substring(1));\n      }\n\n      return '!**' + (prefix !== path.sep ? path.sep : '') + s.slice(1);\n    } // if it starts with a period, then let's get the relative path\n\n\n    if (s.indexOf('.') === 0) {\n      return path.resolve(cwd, s);\n    }\n\n    if (s.indexOf(cwd) === 0) {\n      return s;\n    }\n\n    return '**' + (prefix !== path.sep ? path.sep : '') + s;\n  });\n  debug('rules', rules);\n  var good = [];\n  var whitelist = []; // files that we won't check against the extension\n\n  var ignored = 0;\n  var watched = 0;\n  var usedRules = [];\n  var minimatchOpts = {\n    dot: true\n  }; // enable case-insensitivity on Windows\n\n  if (utils.isWindows) {\n    minimatchOpts.nocase = true;\n  }\n\n  files.forEach(function (file) {\n    file = path.resolve(cwd, file);\n    var matched = false;\n\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].slice(0, 1) === '!') {\n        if (!minimatch(file, rules[i], minimatchOpts)) {\n          debug('ignored', file, 'rule:', rules[i]);\n          ignored++;\n          matched = true;\n          break;\n        }\n      } else {\n        debug('matched', file, 'rule:', rules[i]);\n\n        if (minimatch(file, rules[i], minimatchOpts)) {\n          watched++; // don't repeat the output if a rule is matched\n\n          if (usedRules.indexOf(rules[i]) === -1) {\n            usedRules.push(rules[i]);\n            utils.log.detail('matched rule: ' + rules[i]);\n          } // if the rule doesn't match the WATCH EVERYTHING\n          // but *does* match a rule that ends with *.*, then\n          // white list it - in that we don't run it through\n          // the extension check too.\n\n\n          if (rules[i] !== '**' + path.sep + '*.*' && rules[i].slice(-3) === '*.*') {\n            whitelist.push(file);\n          } else if (path.basename(file) === path.basename(rules[i])) {\n            // if the file matches the actual rule, then it's put on whitelist\n            whitelist.push(file);\n          } else {\n            good.push(file);\n          }\n\n          matched = true;\n          break;\n        } else {// utils.log.detail('no match: ' + rules[i], file);\n        }\n      }\n    }\n\n    if (!matched) {\n      ignored++;\n    }\n  });\n  debug('good', good); // finally check the good files against the extensions that we're monitoring\n\n  if (ext) {\n    if (ext.indexOf(',') === -1) {\n      ext = '**/*.' + ext;\n    } else {\n      ext = '**/*.{' + ext + '}';\n    }\n\n    good = good.filter(function (file) {\n      // only compare the filename to the extension test\n      return minimatch(path.basename(file), ext, minimatchOpts);\n    });\n  } // else assume *.*\n\n\n  var result = good.concat(whitelist);\n\n  if (utils.isWindows) {\n    // fix for windows testing - I *think* this is okay to do\n    result = result.map(function (file) {\n      return file.slice(0, 1).toLowerCase() + file.slice(1);\n    });\n  }\n\n  return {\n    result: result,\n    ignored: ignored,\n    watched: watched,\n    total: files.length\n  };\n}","map":{"version":3,"sources":["/Users/jordanthomson/code/blog-with-Node-React/node_modules/nodemon/lib/monitor/match.js"],"names":["minimatch","require","path","fs","debug","utils","module","exports","match","rulesToMonitor","watch","ignore","config","monitor","Array","isArray","length","clone","push","apply","map","rule","cwd","process","not","slice","dir","resolve","stat","statSync","isDirectory","dirs","Error","e","base","tryBaseDir","indexOf","test","dirname","replace","error","isFile","files","ext","rules","sort","a","b","r","split","sep","aIsIgnore","bIsIgnore","s","prefix","substring","good","whitelist","ignored","watched","usedRules","minimatchOpts","dot","isWindows","nocase","forEach","file","matched","i","log","detail","basename","filter","result","concat","toLowerCase","total"],"mappings":"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","sourcesContent":["const minimatch = require('minimatch');\nconst path = require('path');\nconst fs = require('fs');\nconst debug = require('debug')('nodemon:match');\nconst utils = require('../utils');\n\nmodule.exports = match;\nmodule.exports.rulesToMonitor = rulesToMonitor;\n\nfunction rulesToMonitor(watch, ignore, config) {\n  var monitor = [];\n\n  if (!Array.isArray(ignore)) {\n    if (ignore) {\n      ignore = [ignore];\n    } else {\n      ignore = [];\n    }\n  }\n\n  if (!Array.isArray(watch)) {\n    if (watch) {\n      watch = [watch];\n    } else {\n      watch = [];\n    }\n  }\n\n  if (watch && watch.length) {\n    monitor = utils.clone(watch);\n  }\n\n  if (ignore) {\n    [].push.apply(monitor, (ignore || []).map(function (rule) {\n      return '!' + rule;\n    }));\n  }\n\n  var cwd = process.cwd();\n\n  // next check if the monitored paths are actual directories\n  // or just patterns - and expand the rule to include *.*\n  monitor = monitor.map(function (rule) {\n    var not = rule.slice(0, 1) === '!';\n\n    if (not) {\n      rule = rule.slice(1);\n    }\n\n    if (rule === '.' || rule === '.*') {\n      rule = '*.*';\n    }\n\n    var dir = path.resolve(cwd, rule);\n\n    try {\n      var stat = fs.statSync(dir);\n      if (stat.isDirectory()) {\n        rule = dir;\n        if (rule.slice(-1) !== '/') {\n          rule += '/';\n        }\n        rule += '**/*';\n\n        // `!not` ... sorry.\n        if (!not) {\n          config.dirs.push(dir);\n        }\n      } else {\n        // ensures we end up in the check that tries to get a base directory\n        // and then adds it to the watch list\n        throw new Error();\n      }\n    } catch (e) {\n      var base = tryBaseDir(dir);\n      if (!not && base) {\n        if (config.dirs.indexOf(base) === -1) {\n          config.dirs.push(base);\n        }\n      }\n    }\n\n    if (rule.slice(-1) === '/') {\n      // just slap on a * anyway\n      rule += '*';\n    }\n\n    // if the url ends with * but not **/* and not *.*\n    // then convert to **/* - somehow it was missed :-\\\n    if (rule.slice(-4) !== '**/*' &&\n      rule.slice(-1) === '*' &&\n      rule.indexOf('*.') === -1) {\n\n      if (rule.slice(-2) !== '**') {\n        rule += '*/*';\n      }\n    }\n\n\n    return (not ? '!' : '') + rule;\n  });\n\n  return monitor;\n}\n\nfunction tryBaseDir(dir) {\n  var stat;\n  if (/[?*\\{\\[]+/.test(dir)) { // if this is pattern, then try to find the base\n    try {\n      var base = path.dirname(dir.replace(/([?*\\{\\[]+.*$)/, 'foo'));\n      stat = fs.statSync(base);\n      if (stat.isDirectory()) {\n        return base;\n      }\n    } catch (error) {\n      // console.log(error);\n    }\n  } else {\n    try {\n      stat = fs.statSync(dir);\n      // if this path is actually a single file that exists, then just monitor\n      // that, *specifically*.\n      if (stat.isFile() || stat.isDirectory()) {\n        return dir;\n      }\n    } catch (e) { }\n  }\n\n  return false;\n}\n\nfunction match(files, monitor, ext) {\n  // sort the rules by highest specificity (based on number of slashes)\n  // ignore rules (!) get sorted highest as they take precedent\n  const cwd = process.cwd();\n  var rules = monitor.sort(function (a, b) {\n    var r = b.split(path.sep).length - a.split(path.sep).length;\n    var aIsIgnore = a.slice(0, 1) === '!';\n    var bIsIgnore = b.slice(0, 1) === '!';\n\n    if (aIsIgnore || bIsIgnore) {\n      if (aIsIgnore) {\n        return -1;\n      }\n\n      return 1;\n    }\n\n    if (r === 0) {\n      return b.length - a.length;\n    }\n    return r;\n  }).map(function (s) {\n    var prefix = s.slice(0, 1);\n\n    if (prefix === '!') {\n      if (s.indexOf('!' + cwd) === 0) {\n        return s;\n      }\n\n      // if it starts with a period, then let's get the relative path\n      if (s.indexOf('!.') === 0) {\n        return '!' + path.resolve(cwd, s.substring(1));\n      }\n\n      return '!**' + (prefix !== path.sep ? path.sep : '') + s.slice(1);\n    }\n\n    // if it starts with a period, then let's get the relative path\n    if (s.indexOf('.') === 0) {\n      return path.resolve(cwd, s);\n    }\n\n    if (s.indexOf(cwd) === 0) {\n      return s;\n    }\n\n    return '**' + (prefix !== path.sep ? path.sep : '') + s;\n  });\n\n  debug('rules', rules);\n\n  var good = [];\n  var whitelist = []; // files that we won't check against the extension\n  var ignored = 0;\n  var watched = 0;\n  var usedRules = [];\n  var minimatchOpts = {\n    dot: true,\n  };\n\n  // enable case-insensitivity on Windows\n  if (utils.isWindows) {\n    minimatchOpts.nocase = true;\n  }\n\n  files.forEach(function (file) {\n    file = path.resolve(cwd, file);\n\n    var matched = false;\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].slice(0, 1) === '!') {\n        if (!minimatch(file, rules[i], minimatchOpts)) {\n          debug('ignored', file, 'rule:', rules[i]);\n          ignored++;\n          matched = true;\n          break;\n        }\n      } else {\n        debug('matched', file, 'rule:', rules[i]);\n        if (minimatch(file, rules[i], minimatchOpts)) {\n          watched++;\n\n          // don't repeat the output if a rule is matched\n          if (usedRules.indexOf(rules[i]) === -1) {\n            usedRules.push(rules[i]);\n            utils.log.detail('matched rule: ' + rules[i]);\n          }\n\n          // if the rule doesn't match the WATCH EVERYTHING\n          // but *does* match a rule that ends with *.*, then\n          // white list it - in that we don't run it through\n          // the extension check too.\n          if (rules[i] !== '**' + path.sep + '*.*' &&\n            rules[i].slice(-3) === '*.*') {\n            whitelist.push(file);\n          } else if (path.basename(file) === path.basename(rules[i])) {\n            // if the file matches the actual rule, then it's put on whitelist\n            whitelist.push(file);\n          } else {\n            good.push(file);\n          }\n          matched = true;\n          break;\n        } else {\n          // utils.log.detail('no match: ' + rules[i], file);\n        }\n      }\n    }\n    if (!matched) {\n      ignored++;\n    }\n  });\n\n  debug('good', good)\n\n  // finally check the good files against the extensions that we're monitoring\n  if (ext) {\n    if (ext.indexOf(',') === -1) {\n      ext = '**/*.' + ext;\n    } else {\n      ext = '**/*.{' + ext + '}';\n    }\n\n    good = good.filter(function (file) {\n      // only compare the filename to the extension test\n      return minimatch(path.basename(file), ext, minimatchOpts);\n    });\n  } // else assume *.*\n\n  var result = good.concat(whitelist);\n\n  if (utils.isWindows) {\n    // fix for windows testing - I *think* this is okay to do\n    result = result.map(function (file) {\n      return file.slice(0, 1).toLowerCase() + file.slice(1);\n    });\n  }\n\n  return {\n    result: result,\n    ignored: ignored,\n    watched: watched,\n    total: files.length,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}
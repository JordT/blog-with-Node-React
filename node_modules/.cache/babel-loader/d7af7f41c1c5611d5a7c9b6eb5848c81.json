{"ast":null,"code":"'use strict';\n\nvar utils = require('../utils'); // internal\n\n\nvar reEscComments = /\\\\#/g; // note that '^^' is used in place of escaped comments\n\nvar reUnescapeComments = /\\^\\^/g;\nvar reComments = /#.*$/;\nvar reEscapeChars = /[.|\\-[\\]()\\\\]/g;\nvar reAsterisk = /\\*/g;\nmodule.exports = add;\n/**\n * Converts file patterns or regular expressions to nodemon\n * compatible RegExp matching rules. Note: the `rules` argument\n * object is modified to include the new rule and new RegExp\n *\n * ### Example:\n *\n *     var rules = { watch: [], ignore: [] };\n *     add(rules, 'watch', '*.js');\n *     add(rules, 'ignore', '/public/');\n *     add(rules, 'watch', ':(\\d)*\\.js'); // note: string based regexp\n *     add(rules, 'watch', /\\d*\\.js/);\n *\n * @param {Object} rules containing `watch` and `ignore`. Also updated during\n *                       execution\n * @param {String} which must be either \"watch\" or \"ignore\"\n * @param {String|RegExp} the actual rule.\n */\n\nfunction add(rules, which, rule) {\n  if (!{\n    ignore: 1,\n    watch: 1\n  }[which]) {\n    throw new Error('rules/index.js#add requires \"ignore\" or \"watch\" as the ' + 'first argument');\n  }\n\n  if (Array.isArray(rule)) {\n    rule.forEach(function (rule) {\n      add(rules, which, rule);\n    });\n    return;\n  } // support the rule being a RegExp, but reformat it to\n  // the custom :<regexp> format that we're working with.\n\n\n  if (rule instanceof RegExp) {\n    // rule = ':' + rule.toString().replace(/^\\/(.*?)\\/$/g, '$1');\n    utils.log.error('RegExp format no longer supported, but globs are.');\n    return;\n  } // remove comments and trim lines\n  // this mess of replace methods is escaping \"\\#\" to allow for emacs temp files\n  // first up strip comments and remove blank head or tails\n\n\n  rule = (rule || '').replace(reEscComments, '^^').replace(reComments, '').replace(reUnescapeComments, '#').trim();\n  var regexp = false;\n\n  if (typeof rule === 'string' && rule.substring(0, 1) === ':') {\n    rule = rule.substring(1);\n    utils.log.error('RegExp no longer supported: ' + rule);\n    regexp = true;\n  } else if (rule.length === 0) {\n    // blank line (or it was a comment)\n    return;\n  }\n\n  if (regexp) {// rules[which].push(rule);\n  } else {\n    // rule = rule.replace(reEscapeChars, '\\\\$&')\n    // .replace(reAsterisk, '.*');\n    rules[which].push(rule); // compile a regexp of all the rules for this ignore or watch\n\n    var re = rules[which].map(function (rule) {\n      return rule.replace(reEscapeChars, '\\\\$&').replace(reAsterisk, '.*');\n    }).join('|'); // used for the directory matching\n\n    rules[which].re = new RegExp(re);\n  }\n}","map":{"version":3,"sources":["/Users/jordanthomson/code/blog-with-Node-React/node_modules/nodemon/lib/rules/add.js"],"names":["utils","require","reEscComments","reUnescapeComments","reComments","reEscapeChars","reAsterisk","module","exports","add","rules","which","rule","ignore","watch","Error","Array","isArray","forEach","RegExp","log","error","replace","trim","regexp","substring","length","push","re","map","join"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAAnB,C,CAEA;;;AACA,IAAIC,aAAa,GAAG,MAApB,C,CACA;;AACA,IAAIC,kBAAkB,GAAG,OAAzB;AACA,IAAIC,UAAU,GAAG,MAAjB;AACA,IAAIC,aAAa,GAAG,gBAApB;AACA,IAAIC,UAAU,GAAG,KAAjB;AAEAC,MAAM,CAACC,OAAP,GAAiBC,GAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,GAAT,CAAaC,KAAb,EAAoBC,KAApB,EAA2BC,IAA3B,EAAiC;AAC/B,MAAI,CAAC;AAAEC,IAAAA,MAAM,EAAE,CAAV;AAAaC,IAAAA,KAAK,EAAE;AAApB,IAAuBH,KAAvB,CAAL,EAAoC;AAClC,UAAM,IAAII,KAAJ,CAAU,4DACd,gBADI,CAAN;AAED;;AAED,MAAIC,KAAK,CAACC,OAAN,CAAcL,IAAd,CAAJ,EAAyB;AACvBA,IAAAA,IAAI,CAACM,OAAL,CAAa,UAAUN,IAAV,EAAgB;AAC3BH,MAAAA,GAAG,CAACC,KAAD,EAAQC,KAAR,EAAeC,IAAf,CAAH;AACD,KAFD;AAGA;AACD,GAX8B,CAa/B;AACA;;;AACA,MAAIA,IAAI,YAAYO,MAApB,EAA4B;AAC1B;AACAnB,IAAAA,KAAK,CAACoB,GAAN,CAAUC,KAAV,CAAgB,mDAAhB;AACA;AACD,GAnB8B,CAqB/B;AACA;AAEA;;;AACAT,EAAAA,IAAI,GAAG,CAACA,IAAI,IAAI,EAAT,EAAaU,OAAb,CAAqBpB,aAArB,EAAoC,IAApC,EACKoB,OADL,CACalB,UADb,EACyB,EADzB,EAEKkB,OAFL,CAEanB,kBAFb,EAEiC,GAFjC,EAEsCoB,IAFtC,EAAP;AAIA,MAAIC,MAAM,GAAG,KAAb;;AAEA,MAAI,OAAOZ,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,CAACa,SAAL,CAAe,CAAf,EAAkB,CAAlB,MAAyB,GAAzD,EAA8D;AAC5Db,IAAAA,IAAI,GAAGA,IAAI,CAACa,SAAL,CAAe,CAAf,CAAP;AACAzB,IAAAA,KAAK,CAACoB,GAAN,CAAUC,KAAV,CAAgB,iCAAiCT,IAAjD;AACAY,IAAAA,MAAM,GAAG,IAAT;AACD,GAJD,MAIO,IAAIZ,IAAI,CAACc,MAAL,KAAgB,CAApB,EAAuB;AAC5B;AACA;AACD;;AAED,MAAIF,MAAJ,EAAY,CACV;AACD,GAFD,MAEO;AACL;AACA;AAEAd,IAAAA,KAAK,CAACC,KAAD,CAAL,CAAagB,IAAb,CAAkBf,IAAlB,EAJK,CAKL;;AACA,QAAIgB,EAAE,GAAGlB,KAAK,CAACC,KAAD,CAAL,CAAakB,GAAb,CAAiB,UAAUjB,IAAV,EAAgB;AACxC,aAAOA,IAAI,CAACU,OAAL,CAAajB,aAAb,EAA4B,MAA5B,EACKiB,OADL,CACahB,UADb,EACyB,IADzB,CAAP;AAED,KAHQ,EAGNwB,IAHM,CAGD,GAHC,CAAT,CANK,CAWL;;AACApB,IAAAA,KAAK,CAACC,KAAD,CAAL,CAAaiB,EAAb,GAAkB,IAAIT,MAAJ,CAAWS,EAAX,CAAlB;AACD;AACF","sourcesContent":["'use strict';\n\nvar utils = require('../utils');\n\n// internal\nvar reEscComments = /\\\\#/g;\n// note that '^^' is used in place of escaped comments\nvar reUnescapeComments = /\\^\\^/g;\nvar reComments = /#.*$/;\nvar reEscapeChars = /[.|\\-[\\]()\\\\]/g;\nvar reAsterisk = /\\*/g;\n\nmodule.exports = add;\n\n/**\n * Converts file patterns or regular expressions to nodemon\n * compatible RegExp matching rules. Note: the `rules` argument\n * object is modified to include the new rule and new RegExp\n *\n * ### Example:\n *\n *     var rules = { watch: [], ignore: [] };\n *     add(rules, 'watch', '*.js');\n *     add(rules, 'ignore', '/public/');\n *     add(rules, 'watch', ':(\\d)*\\.js'); // note: string based regexp\n *     add(rules, 'watch', /\\d*\\.js/);\n *\n * @param {Object} rules containing `watch` and `ignore`. Also updated during\n *                       execution\n * @param {String} which must be either \"watch\" or \"ignore\"\n * @param {String|RegExp} the actual rule.\n */\nfunction add(rules, which, rule) {\n  if (!{ ignore: 1, watch: 1}[which]) {\n    throw new Error('rules/index.js#add requires \"ignore\" or \"watch\" as the ' +\n      'first argument');\n  }\n\n  if (Array.isArray(rule)) {\n    rule.forEach(function (rule) {\n      add(rules, which, rule);\n    });\n    return;\n  }\n\n  // support the rule being a RegExp, but reformat it to\n  // the custom :<regexp> format that we're working with.\n  if (rule instanceof RegExp) {\n    // rule = ':' + rule.toString().replace(/^\\/(.*?)\\/$/g, '$1');\n    utils.log.error('RegExp format no longer supported, but globs are.');\n    return;\n  }\n\n  // remove comments and trim lines\n  // this mess of replace methods is escaping \"\\#\" to allow for emacs temp files\n\n  // first up strip comments and remove blank head or tails\n  rule = (rule || '').replace(reEscComments, '^^')\n             .replace(reComments, '')\n             .replace(reUnescapeComments, '#').trim();\n\n  var regexp = false;\n\n  if (typeof rule === 'string' && rule.substring(0, 1) === ':') {\n    rule = rule.substring(1);\n    utils.log.error('RegExp no longer supported: ' + rule);\n    regexp = true;\n  } else if (rule.length === 0) {\n    // blank line (or it was a comment)\n    return;\n  }\n\n  if (regexp) {\n    // rules[which].push(rule);\n  } else {\n    // rule = rule.replace(reEscapeChars, '\\\\$&')\n    // .replace(reAsterisk, '.*');\n\n    rules[which].push(rule);\n    // compile a regexp of all the rules for this ignore or watch\n    var re = rules[which].map(function (rule) {\n      return rule.replace(reEscapeChars, '\\\\$&')\n                 .replace(reAsterisk, '.*');\n    }).join('|');\n\n    // used for the directory matching\n    rules[which].re = new RegExp(re);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst {\n  Readable\n} = require('stream');\n\nconst sysPath = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n\n      return entry => !negative.some(f => f(entry.basename));\n    }\n\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const {\n      root,\n      type\n    } = opts;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat : stat; // Use bigint stats if it's windows and stat() supports options (node 10+).\n\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = 'Dirent' in fs && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const {\n          path,\n          depth,\n          files = []\n        } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n            const entryType = await this._getEntryType(entry);\n\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n\n    return {\n      files,\n      depth,\n      path\n    };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = {\n        path: sysPath.relative(this._root, fullPath),\n        fullPath,\n        basename\n      };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n\n    if (!stats) {\n      return;\n    }\n\n    if (stats.isFile()) {\n      return 'file';\n    }\n\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n\n}\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\n\n\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\nmodule.exports = readdirp;","map":{"version":3,"sources":["/Users/jordanthomson/code/blog-with-Node-React/node_modules/readdirp/index.js"],"names":["fs","require","Readable","sysPath","promisify","picomatch","readdir","stat","lstat","realpath","BANG","RECURSIVE_ERROR_CODE","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","code","maj","min","process","versions","node","split","slice","map","n","Number","parseInt","wantBigintFsStats","platform","normalizeFilter","filter","undefined","glob","trim","entry","basename","Array","isArray","positive","negative","item","trimmed","charAt","push","length","some","f","ReaddirpStream","defaultOptions","root","fileFilter","path","directoryFilter","type","depth","alwaysStat","constructor","options","objectMode","autoDestroy","highWaterMark","opts","_fileFilter","_directoryFilter","statMethod","_stat","bigint","_maxDepth","_wantsDir","includes","_wantsFile","_wantsEverything","_root","resolve","_isDirent","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","parent","_read","batch","destroyed","files","splice","dirent","_formatEntry","Promise","all","entryType","_getEntryType","fullPath","_includeAsFile","pop","destroy","_onError","name","join","relative","err","emit","stats","isFile","isDirectory","isSymbolicLink","full","entryRealPath","entryRealPathStats","len","startsWith","substr","sep","recursiveError","Error","readdirp","TypeError","readdirpPromise","reject","on","promise","default","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var debug = require('debug')('nodemon:run');\n\nconst statSync = require('fs').statSync;\n\nvar utils = require('../utils');\n\nvar bus = utils.bus;\n\nvar childProcess = require('child_process');\n\nvar spawn = childProcess.spawn;\nvar exec = childProcess.exec;\nvar execSync = childProcess.execSync;\nvar fork = childProcess.fork;\n\nvar watch = require('./watch').watch;\n\nvar config = require('../config');\n\nvar child = null; // the actual child process we spawn\n\nvar killedAfterChange = false;\n\nvar noop = () => {};\n\nvar restart = null;\n\nvar psTree = require('pstree.remy');\n\nvar path = require('path');\n\nvar signals = require('./signals');\n\nconst osRelease = parseInt(require('os').release().split('.')[0], 10);\n\nfunction run(options) {\n  var cmd = config.command.raw; // moved up\n  // we need restart function below in the global scope for run.kill\n\n  /*jshint validthis:true*/\n\n  restart = run.bind(this, options);\n  run.restart = restart; // binding options with instance of run\n  // so that we can use it in run.kill\n\n  run.options = options;\n  var runCmd = !options.runOnChangeOnly || config.lastStarted !== 0;\n\n  if (runCmd) {\n    utils.log.status('starting `' + config.command.string + '`');\n  } else {\n    // should just watch file if command is not to be run\n    // had another alternate approach\n    // to stop process being forked/spawned in the below code\n    // but this approach does early exit and makes code cleaner\n    debug('start watch on: %s', config.options.watch);\n\n    if (config.options.watch !== false) {\n      watch();\n      return;\n    }\n  }\n\n  config.lastStarted = Date.now();\n  var stdio = ['pipe', 'pipe', 'pipe'];\n\n  if (config.options.stdout) {\n    stdio = ['pipe', process.stdout, process.stderr];\n  }\n\n  if (config.options.stdin === false) {\n    stdio = [process.stdin, process.stdout, process.stderr];\n  }\n\n  var sh = 'sh';\n  var shFlag = '-c';\n  const binPath = process.cwd() + '/node_modules/.bin';\n  const spawnOptions = {\n    env: Object.assign({}, process.env, options.execOptions.env, {\n      PATH: binPath + ':' + process.env.PATH\n    }),\n    stdio: stdio\n  };\n  var executable = cmd.executable;\n\n  if (utils.isWindows) {\n    // if the exec includes a forward slash, reverse it for windows compat\n    // but *only* apply to the first command, and none of the arguments.\n    // ref #1251 and #1236\n    if (executable.indexOf('/') !== -1) {\n      executable = executable.split(' ').map((e, i) => {\n        if (i === 0) {\n          return path.normalize(e);\n        }\n\n        return e;\n      }).join(' ');\n    } // taken from npm's cli: https://git.io/vNFD4\n\n\n    sh = process.env.comspec || 'cmd';\n    shFlag = '/d /s /c';\n    spawnOptions.windowsVerbatimArguments = true;\n  }\n\n  var args = runCmd ? utils.stringify(executable, cmd.args) : ':';\n  var spawnArgs = [sh, [shFlag, args], spawnOptions];\n  const firstArg = cmd.args[0] || '';\n  var inBinPath = false;\n\n  try {\n    inBinPath = statSync(`${binPath}/${executable}`).isFile();\n  } catch (e) {} // hasStdio allows us to correctly handle stdin piping\n  // see: https://git.io/vNtX3\n\n\n  const hasStdio = utils.satisfies('>= 6.4.0 || < 5'); // forking helps with sub-process handling and tends to clean up better\n  // than spawning, but it should only be used under specific conditions\n\n  const shouldFork = !config.options.spawn && !inBinPath && !(firstArg.indexOf('-') === 0) && // don't fork if there's a node exec arg\n  firstArg !== 'inspect' && // don't fork it's `inspect` debugger\n  executable === 'node' && // only fork if node\n  utils.version.major > 4; // only fork if node version > 4\n\n  if (shouldFork) {\n    // this assumes the first argument is the script and slices it out, since\n    // we're forking\n    var forkArgs = cmd.args.slice(1);\n    var env = utils.merge(options.execOptions.env, process.env);\n    stdio.push('ipc');\n    child = fork(options.execOptions.script, forkArgs, {\n      env: env,\n      stdio: stdio,\n      silent: !hasStdio\n    });\n    utils.log.detail('forking');\n    debug('fork', sh, shFlag, args);\n  } else {\n    utils.log.detail('spawning');\n    child = spawn.apply(null, spawnArgs);\n    debug('spawn', sh, shFlag, args);\n  }\n\n  if (config.required) {\n    var emit = {\n      stdout: function (data) {\n        bus.emit('stdout', data);\n      },\n      stderr: function (data) {\n        bus.emit('stderr', data);\n      }\n    }; // now work out what to bind to...\n\n    if (config.options.stdout) {\n      child.on('stdout', emit.stdout).on('stderr', emit.stderr);\n    } else {\n      child.stdout.on('data', emit.stdout);\n      child.stderr.on('data', emit.stderr);\n      bus.stdout = child.stdout;\n      bus.stderr = child.stderr;\n    }\n\n    if (shouldFork) {\n      child.on('message', function (message, sendHandle) {\n        bus.emit('message', message, sendHandle);\n      });\n    }\n  }\n\n  bus.emit('start');\n  utils.log.detail('child pid: ' + child.pid);\n  child.on('error', function (error) {\n    bus.emit('error', error);\n\n    if (error.code === 'ENOENT') {\n      utils.log.error('unable to run executable: \"' + cmd.executable + '\"');\n      process.exit(1);\n    } else {\n      utils.log.error('failed to start child process: ' + error.code);\n      throw error;\n    }\n  });\n  child.on('exit', function (code, signal) {\n    if (child && child.stdin) {\n      process.stdin.unpipe(child.stdin);\n    }\n\n    if (code === 127) {\n      utils.log.error('failed to start process, \"' + cmd.executable + '\" exec not found');\n      bus.emit('error', code);\n      process.exit();\n    } // If the command failed with code 2, it may or may not be a syntax error\n    // See: http://git.io/fNOAR\n    // We will only assume a parse error, if the child failed quickly\n\n\n    if (code === 2 && Date.now() < config.lastStarted + 500) {\n      utils.log.error('process failed, unhandled exit code (2)');\n      utils.log.error('');\n      utils.log.error('Either the command has a syntax error,');\n      utils.log.error('or it is exiting with reserved code 2.');\n      utils.log.error('');\n      utils.log.error('To keep nodemon running even after a code 2,');\n      utils.log.error('add this to the end of your command: || exit 1');\n      utils.log.error('');\n      utils.log.error('Read more here: https://git.io/fNOAG');\n      utils.log.error('');\n      utils.log.error('nodemon will stop now so that you can fix the command.');\n      utils.log.error('');\n      bus.emit('error', code);\n      process.exit();\n    } // In case we killed the app ourselves, set the signal thusly\n\n\n    if (killedAfterChange) {\n      killedAfterChange = false;\n      signal = config.signal;\n    } // this is nasty, but it gives it windows support\n\n\n    if (utils.isWindows && signal === 'SIGTERM') {\n      signal = config.signal;\n    }\n\n    if (signal === config.signal || code === 0) {\n      // this was a clean exit, so emit exit, rather than crash\n      debug('bus.emit(exit) via ' + config.signal);\n      bus.emit('exit', signal); // exit the monitor, but do it gracefully\n\n      if (signal === config.signal) {\n        return restart();\n      }\n\n      if (code === 0) {\n        // clean exit - wait until file change to restart\n        if (runCmd) {\n          utils.log.status('clean exit - waiting for changes before restart');\n        }\n\n        child = null;\n      }\n    } else {\n      bus.emit('crash');\n\n      if (options.exitcrash) {\n        utils.log.fail('app crashed');\n\n        if (!config.required) {\n          process.exit(1);\n        }\n      } else {\n        utils.log.fail('app crashed - waiting for file changes before' + ' starting...');\n        child = null;\n      }\n    }\n\n    if (config.options.restartable) {\n      // stdin needs to kick in again to be able to listen to the\n      // restart command\n      process.stdin.resume();\n    }\n  }); // moved the run.kill outside to handle both the cases\n  // intial start\n  // no start\n  // connect stdin to the child process (options.stdin is on by default)\n\n  if (options.stdin) {\n    process.stdin.resume(); // FIXME decide whether or not we need to decide the encoding\n    // process.stdin.setEncoding('utf8');\n    // swallow the stdin error if it happens\n    // ref: https://github.com/remy/nodemon/issues/1195\n\n    if (hasStdio) {\n      child.stdin.on('error', () => {});\n      process.stdin.pipe(child.stdin);\n    } else {\n      if (child.stdout) {\n        child.stdout.pipe(process.stdout);\n      } else {\n        utils.log.error('running an unsupported version of node ' + process.version);\n        utils.log.error('nodemon may not work as expected - ' + 'please consider upgrading to LTS');\n      }\n    }\n\n    bus.once('exit', function () {\n      if (child && process.stdin.unpipe) {\n        // node > 0.8\n        process.stdin.unpipe(child.stdin);\n      }\n    });\n  }\n\n  debug('start watch on: %s', config.options.watch);\n\n  if (config.options.watch !== false) {\n    watch();\n  }\n}\n\nfunction waitForSubProcesses(pid, callback) {\n  debug('checking ps tree for pids of ' + pid);\n  psTree(pid, (err, pids) => {\n    if (!pids.length) {\n      return callback();\n    }\n\n    utils.log.status(`still waiting for ${pids.length} sub-process${pids.length > 2 ? 'es' : ''} to finish...`);\n    setTimeout(() => waitForSubProcesses(pid, callback), 1000);\n  });\n}\n\nfunction kill(child, signal, callback) {\n  if (!callback) {\n    callback = noop;\n  }\n\n  if (utils.isWindows) {\n    const taskKill = () => {\n      try {\n        exec('taskkill /pid ' + child.pid + ' /T /F');\n      } catch (e) {\n        utils.log.error('Could not shutdown sub process cleanly');\n      }\n    }; // We are handling a 'SIGKILL' POSIX signal under Windows the\n    // same way it is handled on a UNIX system: We are performing\n    // a hard shutdown without waiting for the process to clean-up.\n\n\n    if (signal === 'SIGKILL' || osRelease < 10) {\n      debug('terminating process group by force: %s', child.pid); // We are using the taskkill utility to terminate the whole\n      // process group ('/t') of the child ('/pid') by force ('/f').\n      // We need to end all sub processes, because the 'child'\n      // process in this context is actually a cmd.exe wrapper.\n\n      taskKill();\n      callback();\n      return;\n    }\n\n    try {\n      // We are using the Windows Management Instrumentation Command-line\n      // (wmic.exe) to resolve the sub-child process identifier, because the\n      // 'child' process in this context is actually a cmd.exe wrapper.\n      // We want to send the termination signal directly to the node process.\n      // The '2> nul' silences the no process found error message.\n      const resultBuffer = execSync(`wmic process where (ParentProcessId=${child.pid}) get ProcessId 2> nul`);\n      const result = resultBuffer.toString().match(/^[0-9]+/m); // If there is no sub-child process we fall back to the child process.\n\n      const processId = Array.isArray(result) ? result[0] : child.pid;\n      debug('sending kill signal SIGINT to process: %s', processId); // We are using the standalone 'windows-kill' executable to send the\n      // standard POSIX signal 'SIGINT' to the node process. This fixes #1720.\n\n      const windowsKill = path.normalize(`${__dirname}/../../bin/windows-kill.exe`); // We have to detach the 'windows-kill' execution completely from this\n      // process group to avoid terminating the nodemon process itself.\n      // See: https://github.com/alirdn/windows-kill#how-it-works--limitations\n      //\n      // Therefore we are using 'start' to create a new cmd.exe context.\n      // The '/min' option hides the new terminal window and the '/wait'\n      // option lets the process wait for the command to finish.\n\n      execSync(`start \"windows-kill\" /min /wait \"${windowsKill}\" -SIGINT ${processId}`);\n    } catch (e) {\n      taskKill();\n    }\n\n    callback();\n  } else {\n    // we use psTree to kill the full subtree of nodemon, because when\n    // spawning processes like `coffee` under the `--debug` flag, it'll spawn\n    // it's own child, and that can't be killed by nodemon, so psTree gives us\n    // an array of PIDs that have spawned under nodemon, and we send each the\n    // configured signal (default: SIGUSR2) signal, which fixes #335\n    // note that psTree also works if `ps` is missing by looking in /proc\n    let sig = signal.replace('SIG', '');\n    psTree(child.pid, function (err, pids) {\n      // if ps isn't native to the OS, then we need to send the numeric value\n      // for the signal during the kill, `signals` is a lookup table for that.\n      if (!psTree.hasPS) {\n        sig = signals[signal];\n      } // the sub processes need to be killed from smallest to largest\n\n\n      debug('sending kill signal to ' + pids.join(', '));\n      child.kill(signal);\n      pids.sort().forEach(pid => exec(`kill -${sig} ${pid}`, noop));\n      waitForSubProcesses(child.pid, () => {\n        // finally kill the main user process\n        exec(`kill -${sig} ${child.pid}`, callback);\n      });\n    });\n  }\n}\n\nrun.kill = function (noRestart, callback) {\n  // I hate code like this :(  - Remy (author of said code)\n  if (typeof noRestart === 'function') {\n    callback = noRestart;\n    noRestart = false;\n  }\n\n  if (!callback) {\n    callback = noop;\n  }\n\n  if (child !== null) {\n    // if the stdin piping is on, we need to unpipe, but also close stdin on\n    // the child, otherwise linux can throw EPIPE or ECONNRESET errors.\n    if (run.options.stdin) {\n      process.stdin.unpipe(child.stdin);\n    } // For the on('exit', ...) handler above the following looks like a\n    // crash, so we set the killedAfterChange flag if a restart is planned\n\n\n    if (!noRestart) {\n      killedAfterChange = true;\n    }\n    /* Now kill the entire subtree of processes belonging to nodemon */\n\n\n    var oldPid = child.pid;\n\n    if (child) {\n      kill(child, config.signal, function () {\n        // this seems to fix the 0.11.x issue with the \"rs\" restart command,\n        // though I'm unsure why. it seems like more data is streamed in to\n        // stdin after we close.\n        if (child && run.options.stdin && child.stdin && oldPid === child.pid) {\n          child.stdin.end();\n        }\n\n        callback();\n      });\n    }\n  } else if (!noRestart) {\n    // if there's no child, then we need to manually start the process\n    // this is because as there was no child, the child.on('exit') event\n    // handler doesn't exist which would normally trigger the restart.\n    bus.once('start', callback);\n    run.restart();\n  } else {\n    callback();\n  }\n};\n\nrun.restart = noop;\nbus.on('quit', function onQuit(code) {\n  if (code === undefined) {\n    code = 0;\n  } // remove event listener\n\n\n  var exitTimer = null;\n\n  var exit = function () {\n    clearTimeout(exitTimer);\n    exit = noop; // null out in case of race condition\n\n    child = null;\n\n    if (!config.required) {\n      // Execute all other quit listeners.\n      bus.listeners('quit').forEach(function (listener) {\n        if (listener !== onQuit) {\n          listener();\n        }\n      });\n      process.exit(code);\n    } else {\n      bus.emit('exit');\n    }\n  }; // if we're not running already, don't bother with trying to kill\n\n\n  if (config.run === false) {\n    return exit();\n  } // immediately try to stop any polling\n\n\n  config.run = false;\n\n  if (child) {\n    // give up waiting for the kids after 10 seconds\n    exitTimer = setTimeout(exit, 10 * 1000);\n    child.removeAllListeners('exit');\n    child.once('exit', exit);\n    kill(child, 'SIGINT');\n  } else {\n    exit();\n  }\n});\nbus.on('restart', function () {\n  // run.kill will send a SIGINT to the child process, which will cause it\n  // to terminate, which in turn uses the 'exit' event handler to restart\n  run.kill();\n}); // remove the child file on exit\n\nprocess.on('exit', function () {\n  utils.log.detail('exiting');\n\n  if (child) {\n    child.kill();\n  }\n}); // because windows borks when listening for the SIG* events\n\nif (!utils.isWindows) {\n  bus.once('boot', () => {\n    // usual suspect: ctrl+c exit\n    process.once('SIGINT', () => bus.emit('quit', 130));\n    process.once('SIGTERM', () => {\n      bus.emit('quit', 143);\n\n      if (child) {\n        child.kill('SIGTERM');\n      }\n    });\n  });\n}\n\nmodule.exports = run;","map":{"version":3,"sources":["/Users/jordanthomson/code/blog-with-Node-React/node_modules/nodemon/lib/monitor/run.js"],"names":["debug","require","statSync","utils","bus","childProcess","spawn","exec","execSync","fork","watch","config","child","killedAfterChange","noop","restart","psTree","path","signals","osRelease","parseInt","release","split","run","options","cmd","command","raw","bind","runCmd","runOnChangeOnly","lastStarted","log","status","string","Date","now","stdio","stdout","process","stderr","stdin","sh","shFlag","binPath","cwd","spawnOptions","env","Object","assign","execOptions","PATH","executable","isWindows","indexOf","map","e","i","normalize","join","comspec","windowsVerbatimArguments","args","stringify","spawnArgs","firstArg","inBinPath","isFile","hasStdio","satisfies","shouldFork","version","major","forkArgs","slice","merge","push","script","silent","detail","apply","required","emit","data","on","message","sendHandle","pid","error","code","exit","signal","unpipe","exitcrash","fail","restartable","resume","pipe","once","waitForSubProcesses","callback","err","pids","length","setTimeout","kill","taskKill","resultBuffer","result","toString","match","processId","Array","isArray","windowsKill","__dirname","sig","replace","hasPS","sort","forEach","noRestart","oldPid","end","onQuit","undefined","exitTimer","clearTimeout","listeners","listener","removeAllListeners","module","exports"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,aAAjB,CAAZ;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,IAAD,CAAP,CAAcC,QAA/B;;AACA,IAAIC,KAAK,GAAGF,OAAO,CAAC,UAAD,CAAnB;;AACA,IAAIG,GAAG,GAAGD,KAAK,CAACC,GAAhB;;AACA,IAAIC,YAAY,GAAGJ,OAAO,CAAC,eAAD,CAA1B;;AACA,IAAIK,KAAK,GAAGD,YAAY,CAACC,KAAzB;AACA,IAAIC,IAAI,GAAGF,YAAY,CAACE,IAAxB;AACA,IAAIC,QAAQ,GAAGH,YAAY,CAACG,QAA5B;AACA,IAAIC,IAAI,GAAGJ,YAAY,CAACI,IAAxB;;AACA,IAAIC,KAAK,GAAGT,OAAO,CAAC,SAAD,CAAP,CAAmBS,KAA/B;;AACA,IAAIC,MAAM,GAAGV,OAAO,CAAC,WAAD,CAApB;;AACA,IAAIW,KAAK,GAAG,IAAZ,C,CAAkB;;AAClB,IAAIC,iBAAiB,GAAG,KAAxB;;AACA,IAAIC,IAAI,GAAG,MAAM,CAAE,CAAnB;;AACA,IAAIC,OAAO,GAAG,IAAd;;AACA,IAAIC,MAAM,GAAGf,OAAO,CAAC,aAAD,CAApB;;AACA,IAAIgB,IAAI,GAAGhB,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIiB,OAAO,GAAGjB,OAAO,CAAC,WAAD,CAArB;;AACA,MAAMkB,SAAS,GAAGC,QAAQ,CAACnB,OAAO,CAAC,IAAD,CAAP,CAAcoB,OAAd,GAAwBC,KAAxB,CAA8B,GAA9B,EAAmC,CAAnC,CAAD,EAAwC,EAAxC,CAA1B;;AAEA,SAASC,GAAT,CAAaC,OAAb,EAAsB;AACpB,MAAIC,GAAG,GAAGd,MAAM,CAACe,OAAP,CAAeC,GAAzB,CADoB,CAEpB;AACA;;AACA;;AACAZ,EAAAA,OAAO,GAAGQ,GAAG,CAACK,IAAJ,CAAS,IAAT,EAAeJ,OAAf,CAAV;AACAD,EAAAA,GAAG,CAACR,OAAJ,GAAcA,OAAd,CANoB,CAQpB;AACA;;AACAQ,EAAAA,GAAG,CAACC,OAAJ,GAAcA,OAAd;AAEA,MAAIK,MAAM,GAAG,CAACL,OAAO,CAACM,eAAT,IAA4BnB,MAAM,CAACoB,WAAP,KAAuB,CAAhE;;AACA,MAAIF,MAAJ,EAAY;AACV1B,IAAAA,KAAK,CAAC6B,GAAN,CAAUC,MAAV,CAAiB,eAAetB,MAAM,CAACe,OAAP,CAAeQ,MAA9B,GAAuC,GAAxD;AACD,GAFD,MAEO;AACL;AACA;AACA;AACA;AACAlC,IAAAA,KAAK,CAAC,oBAAD,EAAuBW,MAAM,CAACa,OAAP,CAAed,KAAtC,CAAL;;AACA,QAAIC,MAAM,CAACa,OAAP,CAAed,KAAf,KAAyB,KAA7B,EAAoC;AAClCA,MAAAA,KAAK;AACL;AACD;AACF;;AAEDC,EAAAA,MAAM,CAACoB,WAAP,GAAqBI,IAAI,CAACC,GAAL,EAArB;AAEA,MAAIC,KAAK,GAAG,CAAC,MAAD,EAAS,MAAT,EAAiB,MAAjB,CAAZ;;AAEA,MAAI1B,MAAM,CAACa,OAAP,CAAec,MAAnB,EAA2B;AACzBD,IAAAA,KAAK,GAAG,CAAC,MAAD,EAASE,OAAO,CAACD,MAAjB,EAAyBC,OAAO,CAACC,MAAjC,CAAR;AACD;;AAED,MAAI7B,MAAM,CAACa,OAAP,CAAeiB,KAAf,KAAyB,KAA7B,EAAoC;AAClCJ,IAAAA,KAAK,GAAG,CAACE,OAAO,CAACE,KAAT,EAAgBF,OAAO,CAACD,MAAxB,EAAgCC,OAAO,CAACC,MAAxC,CAAR;AACD;;AAED,MAAIE,EAAE,GAAG,IAAT;AACA,MAAIC,MAAM,GAAG,IAAb;AAEA,QAAMC,OAAO,GAAGL,OAAO,CAACM,GAAR,KAAgB,oBAAhC;AAEA,QAAMC,YAAY,GAAG;AACnBC,IAAAA,GAAG,EAAEC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBV,OAAO,CAACQ,GAA1B,EAA+BvB,OAAO,CAAC0B,WAAR,CAAoBH,GAAnD,EAAwD;AAC3DI,MAAAA,IAAI,EAAEP,OAAO,GAAG,GAAV,GAAgBL,OAAO,CAACQ,GAAR,CAAYI;AADyB,KAAxD,CADc;AAInBd,IAAAA,KAAK,EAAEA;AAJY,GAArB;AAOA,MAAIe,UAAU,GAAG3B,GAAG,CAAC2B,UAArB;;AAEA,MAAIjD,KAAK,CAACkD,SAAV,EAAqB;AACnB;AACA;AACA;AACA,QAAID,UAAU,CAACE,OAAX,CAAmB,GAAnB,MAA4B,CAAC,CAAjC,EAAoC;AAClCF,MAAAA,UAAU,GAAGA,UAAU,CACpB9B,KADU,CACJ,GADI,EAEViC,GAFU,CAEN,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACb,YAAIA,CAAC,KAAK,CAAV,EAAa;AACX,iBAAOxC,IAAI,CAACyC,SAAL,CAAeF,CAAf,CAAP;AACD;;AACD,eAAOA,CAAP;AACD,OAPU,EAQVG,IARU,CAQL,GARK,CAAb;AASD,KAdkB,CAenB;;;AACAjB,IAAAA,EAAE,GAAGH,OAAO,CAACQ,GAAR,CAAYa,OAAZ,IAAuB,KAA5B;AACAjB,IAAAA,MAAM,GAAG,UAAT;AACAG,IAAAA,YAAY,CAACe,wBAAb,GAAwC,IAAxC;AACD;;AAED,MAAIC,IAAI,GAAGjC,MAAM,GAAG1B,KAAK,CAAC4D,SAAN,CAAgBX,UAAhB,EAA4B3B,GAAG,CAACqC,IAAhC,CAAH,GAA2C,GAA5D;AACA,MAAIE,SAAS,GAAG,CAACtB,EAAD,EAAK,CAACC,MAAD,EAASmB,IAAT,CAAL,EAAqBhB,YAArB,CAAhB;AAEA,QAAMmB,QAAQ,GAAGxC,GAAG,CAACqC,IAAJ,CAAS,CAAT,KAAe,EAAhC;AAEA,MAAII,SAAS,GAAG,KAAhB;;AACA,MAAI;AACFA,IAAAA,SAAS,GAAGhE,QAAQ,CAAE,GAAE0C,OAAQ,IAAGQ,UAAW,EAA1B,CAAR,CAAqCe,MAArC,EAAZ;AACD,GAFD,CAEE,OAAOX,CAAP,EAAU,CAAE,CAlFM,CAoFpB;AACA;;;AACA,QAAMY,QAAQ,GAAGjE,KAAK,CAACkE,SAAN,CAAgB,iBAAhB,CAAjB,CAtFoB,CAwFpB;AACA;;AACA,QAAMC,UAAU,GACd,CAAC3D,MAAM,CAACa,OAAP,CAAelB,KAAhB,IACA,CAAC4D,SADD,IAEA,EAAED,QAAQ,CAACX,OAAT,CAAiB,GAAjB,MAA0B,CAA5B,CAFA,IAEkC;AAClCW,EAAAA,QAAQ,KAAK,SAHb,IAG0B;AAC1Bb,EAAAA,UAAU,KAAK,MAJf,IAIyB;AACzBjD,EAAAA,KAAK,CAACoE,OAAN,CAAcC,KAAd,GAAsB,CANxB,CA1FoB,CAgGO;;AAE3B,MAAIF,UAAJ,EAAgB;AACd;AACA;AACA,QAAIG,QAAQ,GAAGhD,GAAG,CAACqC,IAAJ,CAASY,KAAT,CAAe,CAAf,CAAf;AACA,QAAI3B,GAAG,GAAG5C,KAAK,CAACwE,KAAN,CAAYnD,OAAO,CAAC0B,WAAR,CAAoBH,GAAhC,EAAqCR,OAAO,CAACQ,GAA7C,CAAV;AACAV,IAAAA,KAAK,CAACuC,IAAN,CAAW,KAAX;AACAhE,IAAAA,KAAK,GAAGH,IAAI,CAACe,OAAO,CAAC0B,WAAR,CAAoB2B,MAArB,EAA6BJ,QAA7B,EAAuC;AACjD1B,MAAAA,GAAG,EAAEA,GAD4C;AAEjDV,MAAAA,KAAK,EAAEA,KAF0C;AAGjDyC,MAAAA,MAAM,EAAE,CAACV;AAHwC,KAAvC,CAAZ;AAKAjE,IAAAA,KAAK,CAAC6B,GAAN,CAAU+C,MAAV,CAAiB,SAAjB;AACA/E,IAAAA,KAAK,CAAC,MAAD,EAAS0C,EAAT,EAAaC,MAAb,EAAqBmB,IAArB,CAAL;AACD,GAbD,MAaO;AACL3D,IAAAA,KAAK,CAAC6B,GAAN,CAAU+C,MAAV,CAAiB,UAAjB;AACAnE,IAAAA,KAAK,GAAGN,KAAK,CAAC0E,KAAN,CAAY,IAAZ,EAAkBhB,SAAlB,CAAR;AACAhE,IAAAA,KAAK,CAAC,OAAD,EAAU0C,EAAV,EAAcC,MAAd,EAAsBmB,IAAtB,CAAL;AACD;;AAED,MAAInD,MAAM,CAACsE,QAAX,EAAqB;AACnB,QAAIC,IAAI,GAAG;AACT5C,MAAAA,MAAM,EAAE,UAAU6C,IAAV,EAAgB;AACtB/E,QAAAA,GAAG,CAAC8E,IAAJ,CAAS,QAAT,EAAmBC,IAAnB;AACD,OAHQ;AAIT3C,MAAAA,MAAM,EAAE,UAAU2C,IAAV,EAAgB;AACtB/E,QAAAA,GAAG,CAAC8E,IAAJ,CAAS,QAAT,EAAmBC,IAAnB;AACD;AANQ,KAAX,CADmB,CAUnB;;AACA,QAAIxE,MAAM,CAACa,OAAP,CAAec,MAAnB,EAA2B;AACzB1B,MAAAA,KAAK,CAACwE,EAAN,CAAS,QAAT,EAAmBF,IAAI,CAAC5C,MAAxB,EAAgC8C,EAAhC,CAAmC,QAAnC,EAA6CF,IAAI,CAAC1C,MAAlD;AACD,KAFD,MAEO;AACL5B,MAAAA,KAAK,CAAC0B,MAAN,CAAa8C,EAAb,CAAgB,MAAhB,EAAwBF,IAAI,CAAC5C,MAA7B;AACA1B,MAAAA,KAAK,CAAC4B,MAAN,CAAa4C,EAAb,CAAgB,MAAhB,EAAwBF,IAAI,CAAC1C,MAA7B;AAEApC,MAAAA,GAAG,CAACkC,MAAJ,GAAa1B,KAAK,CAAC0B,MAAnB;AACAlC,MAAAA,GAAG,CAACoC,MAAJ,GAAa5B,KAAK,CAAC4B,MAAnB;AACD;;AAED,QAAI8B,UAAJ,EAAgB;AACd1D,MAAAA,KAAK,CAACwE,EAAN,CAAS,SAAT,EAAoB,UAAUC,OAAV,EAAmBC,UAAnB,EAA+B;AACjDlF,QAAAA,GAAG,CAAC8E,IAAJ,CAAS,SAAT,EAAoBG,OAApB,EAA6BC,UAA7B;AACD,OAFD;AAGD;AACF;;AAEDlF,EAAAA,GAAG,CAAC8E,IAAJ,CAAS,OAAT;AAEA/E,EAAAA,KAAK,CAAC6B,GAAN,CAAU+C,MAAV,CAAiB,gBAAgBnE,KAAK,CAAC2E,GAAvC;AAEA3E,EAAAA,KAAK,CAACwE,EAAN,CAAS,OAAT,EAAkB,UAAUI,KAAV,EAAiB;AACjCpF,IAAAA,GAAG,CAAC8E,IAAJ,CAAS,OAAT,EAAkBM,KAAlB;;AACA,QAAIA,KAAK,CAACC,IAAN,KAAe,QAAnB,EAA6B;AAC3BtF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,gCAAgC/D,GAAG,CAAC2B,UAApC,GAAiD,GAAjE;AACAb,MAAAA,OAAO,CAACmD,IAAR,CAAa,CAAb;AACD,KAHD,MAGO;AACLvF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,oCAAoCA,KAAK,CAACC,IAA1D;AACA,YAAMD,KAAN;AACD;AACF,GATD;AAWA5E,EAAAA,KAAK,CAACwE,EAAN,CAAS,MAAT,EAAiB,UAAUK,IAAV,EAAgBE,MAAhB,EAAwB;AACvC,QAAI/E,KAAK,IAAIA,KAAK,CAAC6B,KAAnB,EAA0B;AACxBF,MAAAA,OAAO,CAACE,KAAR,CAAcmD,MAAd,CAAqBhF,KAAK,CAAC6B,KAA3B;AACD;;AAED,QAAIgD,IAAI,KAAK,GAAb,EAAkB;AAChBtF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CACE,+BAA+B/D,GAAG,CAAC2B,UAAnC,GAAgD,kBADlD;AAGAhD,MAAAA,GAAG,CAAC8E,IAAJ,CAAS,OAAT,EAAkBO,IAAlB;AACAlD,MAAAA,OAAO,CAACmD,IAAR;AACD,KAXsC,CAavC;AACA;AACA;;;AACA,QAAID,IAAI,KAAK,CAAT,IAActD,IAAI,CAACC,GAAL,KAAazB,MAAM,CAACoB,WAAP,GAAqB,GAApD,EAAyD;AACvD5B,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,yCAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,EAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,wCAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,wCAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,EAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,8CAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,gDAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,EAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,sCAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,EAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,wDAAhB;AACArF,MAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,EAAhB;AACApF,MAAAA,GAAG,CAAC8E,IAAJ,CAAS,OAAT,EAAkBO,IAAlB;AACAlD,MAAAA,OAAO,CAACmD,IAAR;AACD,KA/BsC,CAiCvC;;;AACA,QAAI7E,iBAAJ,EAAuB;AACrBA,MAAAA,iBAAiB,GAAG,KAApB;AACA8E,MAAAA,MAAM,GAAGhF,MAAM,CAACgF,MAAhB;AACD,KArCsC,CAsCvC;;;AACA,QAAIxF,KAAK,CAACkD,SAAN,IAAmBsC,MAAM,KAAK,SAAlC,EAA6C;AAC3CA,MAAAA,MAAM,GAAGhF,MAAM,CAACgF,MAAhB;AACD;;AAED,QAAIA,MAAM,KAAKhF,MAAM,CAACgF,MAAlB,IAA4BF,IAAI,KAAK,CAAzC,EAA4C;AAC1C;AACAzF,MAAAA,KAAK,CAAC,wBAAwBW,MAAM,CAACgF,MAAhC,CAAL;AACAvF,MAAAA,GAAG,CAAC8E,IAAJ,CAAS,MAAT,EAAiBS,MAAjB,EAH0C,CAK1C;;AACA,UAAIA,MAAM,KAAKhF,MAAM,CAACgF,MAAtB,EAA8B;AAC5B,eAAO5E,OAAO,EAAd;AACD;;AAED,UAAI0E,IAAI,KAAK,CAAb,EAAgB;AACd;AACA,YAAI5D,MAAJ,EAAY;AACV1B,UAAAA,KAAK,CAAC6B,GAAN,CAAUC,MAAV,CAAiB,iDAAjB;AACD;;AACDrB,QAAAA,KAAK,GAAG,IAAR;AACD;AACF,KAjBD,MAiBO;AACLR,MAAAA,GAAG,CAAC8E,IAAJ,CAAS,OAAT;;AACA,UAAI1D,OAAO,CAACqE,SAAZ,EAAuB;AACrB1F,QAAAA,KAAK,CAAC6B,GAAN,CAAU8D,IAAV,CAAe,aAAf;;AACA,YAAI,CAACnF,MAAM,CAACsE,QAAZ,EAAsB;AACpB1C,UAAAA,OAAO,CAACmD,IAAR,CAAa,CAAb;AACD;AACF,OALD,MAKO;AACLvF,QAAAA,KAAK,CAAC6B,GAAN,CAAU8D,IAAV,CACE,kDAAkD,cADpD;AAGAlF,QAAAA,KAAK,GAAG,IAAR;AACD;AACF;;AAED,QAAID,MAAM,CAACa,OAAP,CAAeuE,WAAnB,EAAgC;AAC9B;AACA;AACAxD,MAAAA,OAAO,CAACE,KAAR,CAAcuD,MAAd;AACD;AACF,GAhFD,EAhKoB,CAkPpB;AACA;AACA;AAEA;;AACA,MAAIxE,OAAO,CAACiB,KAAZ,EAAmB;AACjBF,IAAAA,OAAO,CAACE,KAAR,CAAcuD,MAAd,GADiB,CAEjB;AACA;AAEA;AACA;;AACA,QAAI5B,QAAJ,EAAc;AACZxD,MAAAA,KAAK,CAAC6B,KAAN,CAAY2C,EAAZ,CAAe,OAAf,EAAwB,MAAM,CAAE,CAAhC;AACA7C,MAAAA,OAAO,CAACE,KAAR,CAAcwD,IAAd,CAAmBrF,KAAK,CAAC6B,KAAzB;AACD,KAHD,MAGO;AACL,UAAI7B,KAAK,CAAC0B,MAAV,EAAkB;AAChB1B,QAAAA,KAAK,CAAC0B,MAAN,CAAa2D,IAAb,CAAkB1D,OAAO,CAACD,MAA1B;AACD,OAFD,MAEO;AACLnC,QAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CACE,4CAA4CjD,OAAO,CAACgC,OADtD;AAGApE,QAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CACE,wCACE,kCAFJ;AAID;AACF;;AAEDpF,IAAAA,GAAG,CAAC8F,IAAJ,CAAS,MAAT,EAAiB,YAAY;AAC3B,UAAItF,KAAK,IAAI2B,OAAO,CAACE,KAAR,CAAcmD,MAA3B,EAAmC;AACjC;AACArD,QAAAA,OAAO,CAACE,KAAR,CAAcmD,MAAd,CAAqBhF,KAAK,CAAC6B,KAA3B;AACD;AACF,KALD;AAMD;;AAEDzC,EAAAA,KAAK,CAAC,oBAAD,EAAuBW,MAAM,CAACa,OAAP,CAAed,KAAtC,CAAL;;AACA,MAAIC,MAAM,CAACa,OAAP,CAAed,KAAf,KAAyB,KAA7B,EAAoC;AAClCA,IAAAA,KAAK;AACN;AACF;;AAED,SAASyF,mBAAT,CAA6BZ,GAA7B,EAAkCa,QAAlC,EAA4C;AAC1CpG,EAAAA,KAAK,CAAC,kCAAkCuF,GAAnC,CAAL;AACAvE,EAAAA,MAAM,CAACuE,GAAD,EAAM,CAACc,GAAD,EAAMC,IAAN,KAAe;AACzB,QAAI,CAACA,IAAI,CAACC,MAAV,EAAkB;AAChB,aAAOH,QAAQ,EAAf;AACD;;AAEDjG,IAAAA,KAAK,CAAC6B,GAAN,CAAUC,MAAV,CACG,qBAAoBqE,IAAI,CAACC,MAAO,eAC/BD,IAAI,CAACC,MAAL,GAAc,CAAd,GAAkB,IAAlB,GAAyB,EAC1B,eAHH;AAKAC,IAAAA,UAAU,CAAC,MAAML,mBAAmB,CAACZ,GAAD,EAAMa,QAAN,CAA1B,EAA2C,IAA3C,CAAV;AACD,GAXK,CAAN;AAYD;;AAED,SAASK,IAAT,CAAc7F,KAAd,EAAqB+E,MAArB,EAA6BS,QAA7B,EAAuC;AACrC,MAAI,CAACA,QAAL,EAAe;AACbA,IAAAA,QAAQ,GAAGtF,IAAX;AACD;;AAED,MAAIX,KAAK,CAACkD,SAAV,EAAqB;AACnB,UAAMqD,QAAQ,GAAG,MAAM;AACrB,UAAI;AACFnG,QAAAA,IAAI,CAAC,mBAAmBK,KAAK,CAAC2E,GAAzB,GAA+B,QAAhC,CAAJ;AACD,OAFD,CAEE,OAAO/B,CAAP,EAAU;AACVrD,QAAAA,KAAK,CAAC6B,GAAN,CAAUwD,KAAV,CAAgB,wCAAhB;AACD;AACF,KAND,CADmB,CASnB;AACA;AACA;;;AACA,QAAIG,MAAM,KAAK,SAAX,IAAwBxE,SAAS,GAAG,EAAxC,EAA4C;AAC1CnB,MAAAA,KAAK,CAAC,wCAAD,EAA2CY,KAAK,CAAC2E,GAAjD,CAAL,CAD0C,CAG1C;AACA;AACA;AACA;;AACAmB,MAAAA,QAAQ;AACRN,MAAAA,QAAQ;AACR;AACD;;AAED,QAAI;AACF;AACA;AACA;AACA;AACA;AACA,YAAMO,YAAY,GAAGnG,QAAQ,CAC1B,uCAAsCI,KAAK,CAAC2E,GAAI,wBADtB,CAA7B;AAGA,YAAMqB,MAAM,GAAGD,YAAY,CAACE,QAAb,GAAwBC,KAAxB,CAA8B,UAA9B,CAAf,CATE,CAWF;;AACA,YAAMC,SAAS,GAAGC,KAAK,CAACC,OAAN,CAAcL,MAAd,IAAwBA,MAAM,CAAC,CAAD,CAA9B,GAAoChG,KAAK,CAAC2E,GAA5D;AAEAvF,MAAAA,KAAK,CAAC,2CAAD,EAA8C+G,SAA9C,CAAL,CAdE,CAgBF;AACA;;AACA,YAAMG,WAAW,GAAGjG,IAAI,CAACyC,SAAL,CACjB,GAAEyD,SAAU,6BADK,CAApB,CAlBE,CAsBF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA3G,MAAAA,QAAQ,CACL,oCAAmC0G,WAAY,aAAYH,SAAU,EADhE,CAAR;AAGD,KAjCD,CAiCE,OAAOvD,CAAP,EAAU;AACVkD,MAAAA,QAAQ;AACT;;AACDN,IAAAA,QAAQ;AACT,GA7DD,MA6DO;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAIgB,GAAG,GAAGzB,MAAM,CAAC0B,OAAP,CAAe,KAAf,EAAsB,EAAtB,CAAV;AAEArG,IAAAA,MAAM,CAACJ,KAAK,CAAC2E,GAAP,EAAY,UAAUc,GAAV,EAAeC,IAAf,EAAqB;AACrC;AACA;AACA,UAAI,CAACtF,MAAM,CAACsG,KAAZ,EAAmB;AACjBF,QAAAA,GAAG,GAAGlG,OAAO,CAACyE,MAAD,CAAb;AACD,OALoC,CAOrC;;;AACA3F,MAAAA,KAAK,CAAC,4BAA4BsG,IAAI,CAAC3C,IAAL,CAAU,IAAV,CAA7B,CAAL;AAEA/C,MAAAA,KAAK,CAAC6F,IAAN,CAAWd,MAAX;AAEAW,MAAAA,IAAI,CAACiB,IAAL,GAAYC,OAAZ,CAAqBjC,GAAD,IAAShF,IAAI,CAAE,SAAQ6G,GAAI,IAAG7B,GAAI,EAArB,EAAwBzE,IAAxB,CAAjC;AAEAqF,MAAAA,mBAAmB,CAACvF,KAAK,CAAC2E,GAAP,EAAY,MAAM;AACnC;AACAhF,QAAAA,IAAI,CAAE,SAAQ6G,GAAI,IAAGxG,KAAK,CAAC2E,GAAI,EAA3B,EAA8Ba,QAA9B,CAAJ;AACD,OAHkB,CAAnB;AAID,KAlBK,CAAN;AAmBD;AACF;;AAED7E,GAAG,CAACkF,IAAJ,GAAW,UAAUgB,SAAV,EAAqBrB,QAArB,EAA+B;AACxC;AACA,MAAI,OAAOqB,SAAP,KAAqB,UAAzB,EAAqC;AACnCrB,IAAAA,QAAQ,GAAGqB,SAAX;AACAA,IAAAA,SAAS,GAAG,KAAZ;AACD;;AAED,MAAI,CAACrB,QAAL,EAAe;AACbA,IAAAA,QAAQ,GAAGtF,IAAX;AACD;;AAED,MAAIF,KAAK,KAAK,IAAd,EAAoB;AAClB;AACA;AACA,QAAIW,GAAG,CAACC,OAAJ,CAAYiB,KAAhB,EAAuB;AACrBF,MAAAA,OAAO,CAACE,KAAR,CAAcmD,MAAd,CAAqBhF,KAAK,CAAC6B,KAA3B;AACD,KALiB,CAOlB;AACA;;;AACA,QAAI,CAACgF,SAAL,EAAgB;AACd5G,MAAAA,iBAAiB,GAAG,IAApB;AACD;AAED;;;AACA,QAAI6G,MAAM,GAAG9G,KAAK,CAAC2E,GAAnB;;AACA,QAAI3E,KAAJ,EAAW;AACT6F,MAAAA,IAAI,CAAC7F,KAAD,EAAQD,MAAM,CAACgF,MAAf,EAAuB,YAAY;AACrC;AACA;AACA;AACA,YAAI/E,KAAK,IAAIW,GAAG,CAACC,OAAJ,CAAYiB,KAArB,IAA8B7B,KAAK,CAAC6B,KAApC,IAA6CiF,MAAM,KAAK9G,KAAK,CAAC2E,GAAlE,EAAuE;AACrE3E,UAAAA,KAAK,CAAC6B,KAAN,CAAYkF,GAAZ;AACD;;AACDvB,QAAAA,QAAQ;AACT,OARG,CAAJ;AASD;AACF,GA1BD,MA0BO,IAAI,CAACqB,SAAL,EAAgB;AACrB;AACA;AACA;AACArH,IAAAA,GAAG,CAAC8F,IAAJ,CAAS,OAAT,EAAkBE,QAAlB;AACA7E,IAAAA,GAAG,CAACR,OAAJ;AACD,GANM,MAMA;AACLqF,IAAAA,QAAQ;AACT;AACF,CA9CD;;AAgDA7E,GAAG,CAACR,OAAJ,GAAcD,IAAd;AAEAV,GAAG,CAACgF,EAAJ,CAAO,MAAP,EAAe,SAASwC,MAAT,CAAgBnC,IAAhB,EAAsB;AACnC,MAAIA,IAAI,KAAKoC,SAAb,EAAwB;AACtBpC,IAAAA,IAAI,GAAG,CAAP;AACD,GAHkC,CAKnC;;;AACA,MAAIqC,SAAS,GAAG,IAAhB;;AACA,MAAIpC,IAAI,GAAG,YAAY;AACrBqC,IAAAA,YAAY,CAACD,SAAD,CAAZ;AACApC,IAAAA,IAAI,GAAG5E,IAAP,CAFqB,CAER;;AACbF,IAAAA,KAAK,GAAG,IAAR;;AACA,QAAI,CAACD,MAAM,CAACsE,QAAZ,EAAsB;AACpB;AACA7E,MAAAA,GAAG,CAAC4H,SAAJ,CAAc,MAAd,EAAsBR,OAAtB,CAA8B,UAAUS,QAAV,EAAoB;AAChD,YAAIA,QAAQ,KAAKL,MAAjB,EAAyB;AACvBK,UAAAA,QAAQ;AACT;AACF,OAJD;AAKA1F,MAAAA,OAAO,CAACmD,IAAR,CAAaD,IAAb;AACD,KARD,MAQO;AACLrF,MAAAA,GAAG,CAAC8E,IAAJ,CAAS,MAAT;AACD;AACF,GAfD,CAPmC,CAwBnC;;;AACA,MAAIvE,MAAM,CAACY,GAAP,KAAe,KAAnB,EAA0B;AACxB,WAAOmE,IAAI,EAAX;AACD,GA3BkC,CA6BnC;;;AACA/E,EAAAA,MAAM,CAACY,GAAP,GAAa,KAAb;;AAEA,MAAIX,KAAJ,EAAW;AACT;AACAkH,IAAAA,SAAS,GAAGtB,UAAU,CAACd,IAAD,EAAO,KAAK,IAAZ,CAAtB;AACA9E,IAAAA,KAAK,CAACsH,kBAAN,CAAyB,MAAzB;AACAtH,IAAAA,KAAK,CAACsF,IAAN,CAAW,MAAX,EAAmBR,IAAnB;AAEAe,IAAAA,IAAI,CAAC7F,KAAD,EAAQ,QAAR,CAAJ;AACD,GAPD,MAOO;AACL8E,IAAAA,IAAI;AACL;AACF,CA1CD;AA4CAtF,GAAG,CAACgF,EAAJ,CAAO,SAAP,EAAkB,YAAY;AAC5B;AACA;AACA7D,EAAAA,GAAG,CAACkF,IAAJ;AACD,CAJD,E,CAMA;;AACAlE,OAAO,CAAC6C,EAAR,CAAW,MAAX,EAAmB,YAAY;AAC7BjF,EAAAA,KAAK,CAAC6B,GAAN,CAAU+C,MAAV,CAAiB,SAAjB;;AACA,MAAInE,KAAJ,EAAW;AACTA,IAAAA,KAAK,CAAC6F,IAAN;AACD;AACF,CALD,E,CAOA;;AACA,IAAI,CAACtG,KAAK,CAACkD,SAAX,EAAsB;AACpBjD,EAAAA,GAAG,CAAC8F,IAAJ,CAAS,MAAT,EAAiB,MAAM;AACrB;AACA3D,IAAAA,OAAO,CAAC2D,IAAR,CAAa,QAAb,EAAuB,MAAM9F,GAAG,CAAC8E,IAAJ,CAAS,MAAT,EAAiB,GAAjB,CAA7B;AACA3C,IAAAA,OAAO,CAAC2D,IAAR,CAAa,SAAb,EAAwB,MAAM;AAC5B9F,MAAAA,GAAG,CAAC8E,IAAJ,CAAS,MAAT,EAAiB,GAAjB;;AACA,UAAItE,KAAJ,EAAW;AACTA,QAAAA,KAAK,CAAC6F,IAAN,CAAW,SAAX;AACD;AACF,KALD;AAMD,GATD;AAUD;;AAED0B,MAAM,CAACC,OAAP,GAAiB7G,GAAjB","sourcesContent":["var debug = require('debug')('nodemon:run');\nconst statSync = require('fs').statSync;\nvar utils = require('../utils');\nvar bus = utils.bus;\nvar childProcess = require('child_process');\nvar spawn = childProcess.spawn;\nvar exec = childProcess.exec;\nvar execSync = childProcess.execSync;\nvar fork = childProcess.fork;\nvar watch = require('./watch').watch;\nvar config = require('../config');\nvar child = null; // the actual child process we spawn\nvar killedAfterChange = false;\nvar noop = () => {};\nvar restart = null;\nvar psTree = require('pstree.remy');\nvar path = require('path');\nvar signals = require('./signals');\nconst osRelease = parseInt(require('os').release().split('.')[0], 10);\n\nfunction run(options) {\n  var cmd = config.command.raw;\n  // moved up\n  // we need restart function below in the global scope for run.kill\n  /*jshint validthis:true*/\n  restart = run.bind(this, options);\n  run.restart = restart;\n\n  // binding options with instance of run\n  // so that we can use it in run.kill\n  run.options = options;\n\n  var runCmd = !options.runOnChangeOnly || config.lastStarted !== 0;\n  if (runCmd) {\n    utils.log.status('starting `' + config.command.string + '`');\n  } else {\n    // should just watch file if command is not to be run\n    // had another alternate approach\n    // to stop process being forked/spawned in the below code\n    // but this approach does early exit and makes code cleaner\n    debug('start watch on: %s', config.options.watch);\n    if (config.options.watch !== false) {\n      watch();\n      return;\n    }\n  }\n\n  config.lastStarted = Date.now();\n\n  var stdio = ['pipe', 'pipe', 'pipe'];\n\n  if (config.options.stdout) {\n    stdio = ['pipe', process.stdout, process.stderr];\n  }\n\n  if (config.options.stdin === false) {\n    stdio = [process.stdin, process.stdout, process.stderr];\n  }\n\n  var sh = 'sh';\n  var shFlag = '-c';\n\n  const binPath = process.cwd() + '/node_modules/.bin';\n\n  const spawnOptions = {\n    env: Object.assign({}, process.env, options.execOptions.env, {\n      PATH: binPath + ':' + process.env.PATH,\n    }),\n    stdio: stdio,\n  };\n\n  var executable = cmd.executable;\n\n  if (utils.isWindows) {\n    // if the exec includes a forward slash, reverse it for windows compat\n    // but *only* apply to the first command, and none of the arguments.\n    // ref #1251 and #1236\n    if (executable.indexOf('/') !== -1) {\n      executable = executable\n        .split(' ')\n        .map((e, i) => {\n          if (i === 0) {\n            return path.normalize(e);\n          }\n          return e;\n        })\n        .join(' ');\n    }\n    // taken from npm's cli: https://git.io/vNFD4\n    sh = process.env.comspec || 'cmd';\n    shFlag = '/d /s /c';\n    spawnOptions.windowsVerbatimArguments = true;\n  }\n\n  var args = runCmd ? utils.stringify(executable, cmd.args) : ':';\n  var spawnArgs = [sh, [shFlag, args], spawnOptions];\n\n  const firstArg = cmd.args[0] || '';\n\n  var inBinPath = false;\n  try {\n    inBinPath = statSync(`${binPath}/${executable}`).isFile();\n  } catch (e) {}\n\n  // hasStdio allows us to correctly handle stdin piping\n  // see: https://git.io/vNtX3\n  const hasStdio = utils.satisfies('>= 6.4.0 || < 5');\n\n  // forking helps with sub-process handling and tends to clean up better\n  // than spawning, but it should only be used under specific conditions\n  const shouldFork =\n    !config.options.spawn &&\n    !inBinPath &&\n    !(firstArg.indexOf('-') === 0) && // don't fork if there's a node exec arg\n    firstArg !== 'inspect' && // don't fork it's `inspect` debugger\n    executable === 'node' && // only fork if node\n    utils.version.major > 4; // only fork if node version > 4\n\n  if (shouldFork) {\n    // this assumes the first argument is the script and slices it out, since\n    // we're forking\n    var forkArgs = cmd.args.slice(1);\n    var env = utils.merge(options.execOptions.env, process.env);\n    stdio.push('ipc');\n    child = fork(options.execOptions.script, forkArgs, {\n      env: env,\n      stdio: stdio,\n      silent: !hasStdio,\n    });\n    utils.log.detail('forking');\n    debug('fork', sh, shFlag, args);\n  } else {\n    utils.log.detail('spawning');\n    child = spawn.apply(null, spawnArgs);\n    debug('spawn', sh, shFlag, args);\n  }\n\n  if (config.required) {\n    var emit = {\n      stdout: function (data) {\n        bus.emit('stdout', data);\n      },\n      stderr: function (data) {\n        bus.emit('stderr', data);\n      },\n    };\n\n    // now work out what to bind to...\n    if (config.options.stdout) {\n      child.on('stdout', emit.stdout).on('stderr', emit.stderr);\n    } else {\n      child.stdout.on('data', emit.stdout);\n      child.stderr.on('data', emit.stderr);\n\n      bus.stdout = child.stdout;\n      bus.stderr = child.stderr;\n    }\n\n    if (shouldFork) {\n      child.on('message', function (message, sendHandle) {\n        bus.emit('message', message, sendHandle);\n      });\n    }\n  }\n\n  bus.emit('start');\n\n  utils.log.detail('child pid: ' + child.pid);\n\n  child.on('error', function (error) {\n    bus.emit('error', error);\n    if (error.code === 'ENOENT') {\n      utils.log.error('unable to run executable: \"' + cmd.executable + '\"');\n      process.exit(1);\n    } else {\n      utils.log.error('failed to start child process: ' + error.code);\n      throw error;\n    }\n  });\n\n  child.on('exit', function (code, signal) {\n    if (child && child.stdin) {\n      process.stdin.unpipe(child.stdin);\n    }\n\n    if (code === 127) {\n      utils.log.error(\n        'failed to start process, \"' + cmd.executable + '\" exec not found'\n      );\n      bus.emit('error', code);\n      process.exit();\n    }\n\n    // If the command failed with code 2, it may or may not be a syntax error\n    // See: http://git.io/fNOAR\n    // We will only assume a parse error, if the child failed quickly\n    if (code === 2 && Date.now() < config.lastStarted + 500) {\n      utils.log.error('process failed, unhandled exit code (2)');\n      utils.log.error('');\n      utils.log.error('Either the command has a syntax error,');\n      utils.log.error('or it is exiting with reserved code 2.');\n      utils.log.error('');\n      utils.log.error('To keep nodemon running even after a code 2,');\n      utils.log.error('add this to the end of your command: || exit 1');\n      utils.log.error('');\n      utils.log.error('Read more here: https://git.io/fNOAG');\n      utils.log.error('');\n      utils.log.error('nodemon will stop now so that you can fix the command.');\n      utils.log.error('');\n      bus.emit('error', code);\n      process.exit();\n    }\n\n    // In case we killed the app ourselves, set the signal thusly\n    if (killedAfterChange) {\n      killedAfterChange = false;\n      signal = config.signal;\n    }\n    // this is nasty, but it gives it windows support\n    if (utils.isWindows && signal === 'SIGTERM') {\n      signal = config.signal;\n    }\n\n    if (signal === config.signal || code === 0) {\n      // this was a clean exit, so emit exit, rather than crash\n      debug('bus.emit(exit) via ' + config.signal);\n      bus.emit('exit', signal);\n\n      // exit the monitor, but do it gracefully\n      if (signal === config.signal) {\n        return restart();\n      }\n\n      if (code === 0) {\n        // clean exit - wait until file change to restart\n        if (runCmd) {\n          utils.log.status('clean exit - waiting for changes before restart');\n        }\n        child = null;\n      }\n    } else {\n      bus.emit('crash');\n      if (options.exitcrash) {\n        utils.log.fail('app crashed');\n        if (!config.required) {\n          process.exit(1);\n        }\n      } else {\n        utils.log.fail(\n          'app crashed - waiting for file changes before' + ' starting...'\n        );\n        child = null;\n      }\n    }\n\n    if (config.options.restartable) {\n      // stdin needs to kick in again to be able to listen to the\n      // restart command\n      process.stdin.resume();\n    }\n  });\n\n  // moved the run.kill outside to handle both the cases\n  // intial start\n  // no start\n\n  // connect stdin to the child process (options.stdin is on by default)\n  if (options.stdin) {\n    process.stdin.resume();\n    // FIXME decide whether or not we need to decide the encoding\n    // process.stdin.setEncoding('utf8');\n\n    // swallow the stdin error if it happens\n    // ref: https://github.com/remy/nodemon/issues/1195\n    if (hasStdio) {\n      child.stdin.on('error', () => {});\n      process.stdin.pipe(child.stdin);\n    } else {\n      if (child.stdout) {\n        child.stdout.pipe(process.stdout);\n      } else {\n        utils.log.error(\n          'running an unsupported version of node ' + process.version\n        );\n        utils.log.error(\n          'nodemon may not work as expected - ' +\n            'please consider upgrading to LTS'\n        );\n      }\n    }\n\n    bus.once('exit', function () {\n      if (child && process.stdin.unpipe) {\n        // node > 0.8\n        process.stdin.unpipe(child.stdin);\n      }\n    });\n  }\n\n  debug('start watch on: %s', config.options.watch);\n  if (config.options.watch !== false) {\n    watch();\n  }\n}\n\nfunction waitForSubProcesses(pid, callback) {\n  debug('checking ps tree for pids of ' + pid);\n  psTree(pid, (err, pids) => {\n    if (!pids.length) {\n      return callback();\n    }\n\n    utils.log.status(\n      `still waiting for ${pids.length} sub-process${\n        pids.length > 2 ? 'es' : ''\n      } to finish...`\n    );\n    setTimeout(() => waitForSubProcesses(pid, callback), 1000);\n  });\n}\n\nfunction kill(child, signal, callback) {\n  if (!callback) {\n    callback = noop;\n  }\n\n  if (utils.isWindows) {\n    const taskKill = () => {\n      try {\n        exec('taskkill /pid ' + child.pid + ' /T /F');\n      } catch (e) {\n        utils.log.error('Could not shutdown sub process cleanly');\n      }\n    };\n\n    // We are handling a 'SIGKILL' POSIX signal under Windows the\n    // same way it is handled on a UNIX system: We are performing\n    // a hard shutdown without waiting for the process to clean-up.\n    if (signal === 'SIGKILL' || osRelease < 10) {\n      debug('terminating process group by force: %s', child.pid);\n\n      // We are using the taskkill utility to terminate the whole\n      // process group ('/t') of the child ('/pid') by force ('/f').\n      // We need to end all sub processes, because the 'child'\n      // process in this context is actually a cmd.exe wrapper.\n      taskKill();\n      callback();\n      return;\n    }\n\n    try {\n      // We are using the Windows Management Instrumentation Command-line\n      // (wmic.exe) to resolve the sub-child process identifier, because the\n      // 'child' process in this context is actually a cmd.exe wrapper.\n      // We want to send the termination signal directly to the node process.\n      // The '2> nul' silences the no process found error message.\n      const resultBuffer = execSync(\n        `wmic process where (ParentProcessId=${child.pid}) get ProcessId 2> nul`\n      );\n      const result = resultBuffer.toString().match(/^[0-9]+/m);\n\n      // If there is no sub-child process we fall back to the child process.\n      const processId = Array.isArray(result) ? result[0] : child.pid;\n\n      debug('sending kill signal SIGINT to process: %s', processId);\n\n      // We are using the standalone 'windows-kill' executable to send the\n      // standard POSIX signal 'SIGINT' to the node process. This fixes #1720.\n      const windowsKill = path.normalize(\n        `${__dirname}/../../bin/windows-kill.exe`\n      );\n\n      // We have to detach the 'windows-kill' execution completely from this\n      // process group to avoid terminating the nodemon process itself.\n      // See: https://github.com/alirdn/windows-kill#how-it-works--limitations\n      //\n      // Therefore we are using 'start' to create a new cmd.exe context.\n      // The '/min' option hides the new terminal window and the '/wait'\n      // option lets the process wait for the command to finish.\n\n      execSync(\n        `start \"windows-kill\" /min /wait \"${windowsKill}\" -SIGINT ${processId}`\n      );\n    } catch (e) {\n      taskKill();\n    }\n    callback();\n  } else {\n    // we use psTree to kill the full subtree of nodemon, because when\n    // spawning processes like `coffee` under the `--debug` flag, it'll spawn\n    // it's own child, and that can't be killed by nodemon, so psTree gives us\n    // an array of PIDs that have spawned under nodemon, and we send each the\n    // configured signal (default: SIGUSR2) signal, which fixes #335\n    // note that psTree also works if `ps` is missing by looking in /proc\n    let sig = signal.replace('SIG', '');\n\n    psTree(child.pid, function (err, pids) {\n      // if ps isn't native to the OS, then we need to send the numeric value\n      // for the signal during the kill, `signals` is a lookup table for that.\n      if (!psTree.hasPS) {\n        sig = signals[signal];\n      }\n\n      // the sub processes need to be killed from smallest to largest\n      debug('sending kill signal to ' + pids.join(', '));\n\n      child.kill(signal);\n\n      pids.sort().forEach((pid) => exec(`kill -${sig} ${pid}`, noop));\n\n      waitForSubProcesses(child.pid, () => {\n        // finally kill the main user process\n        exec(`kill -${sig} ${child.pid}`, callback);\n      });\n    });\n  }\n}\n\nrun.kill = function (noRestart, callback) {\n  // I hate code like this :(  - Remy (author of said code)\n  if (typeof noRestart === 'function') {\n    callback = noRestart;\n    noRestart = false;\n  }\n\n  if (!callback) {\n    callback = noop;\n  }\n\n  if (child !== null) {\n    // if the stdin piping is on, we need to unpipe, but also close stdin on\n    // the child, otherwise linux can throw EPIPE or ECONNRESET errors.\n    if (run.options.stdin) {\n      process.stdin.unpipe(child.stdin);\n    }\n\n    // For the on('exit', ...) handler above the following looks like a\n    // crash, so we set the killedAfterChange flag if a restart is planned\n    if (!noRestart) {\n      killedAfterChange = true;\n    }\n\n    /* Now kill the entire subtree of processes belonging to nodemon */\n    var oldPid = child.pid;\n    if (child) {\n      kill(child, config.signal, function () {\n        // this seems to fix the 0.11.x issue with the \"rs\" restart command,\n        // though I'm unsure why. it seems like more data is streamed in to\n        // stdin after we close.\n        if (child && run.options.stdin && child.stdin && oldPid === child.pid) {\n          child.stdin.end();\n        }\n        callback();\n      });\n    }\n  } else if (!noRestart) {\n    // if there's no child, then we need to manually start the process\n    // this is because as there was no child, the child.on('exit') event\n    // handler doesn't exist which would normally trigger the restart.\n    bus.once('start', callback);\n    run.restart();\n  } else {\n    callback();\n  }\n};\n\nrun.restart = noop;\n\nbus.on('quit', function onQuit(code) {\n  if (code === undefined) {\n    code = 0;\n  }\n\n  // remove event listener\n  var exitTimer = null;\n  var exit = function () {\n    clearTimeout(exitTimer);\n    exit = noop; // null out in case of race condition\n    child = null;\n    if (!config.required) {\n      // Execute all other quit listeners.\n      bus.listeners('quit').forEach(function (listener) {\n        if (listener !== onQuit) {\n          listener();\n        }\n      });\n      process.exit(code);\n    } else {\n      bus.emit('exit');\n    }\n  };\n\n  // if we're not running already, don't bother with trying to kill\n  if (config.run === false) {\n    return exit();\n  }\n\n  // immediately try to stop any polling\n  config.run = false;\n\n  if (child) {\n    // give up waiting for the kids after 10 seconds\n    exitTimer = setTimeout(exit, 10 * 1000);\n    child.removeAllListeners('exit');\n    child.once('exit', exit);\n\n    kill(child, 'SIGINT');\n  } else {\n    exit();\n  }\n});\n\nbus.on('restart', function () {\n  // run.kill will send a SIGINT to the child process, which will cause it\n  // to terminate, which in turn uses the 'exit' event handler to restart\n  run.kill();\n});\n\n// remove the child file on exit\nprocess.on('exit', function () {\n  utils.log.detail('exiting');\n  if (child) {\n    child.kill();\n  }\n});\n\n// because windows borks when listening for the SIG* events\nif (!utils.isWindows) {\n  bus.once('boot', () => {\n    // usual suspect: ctrl+c exit\n    process.once('SIGINT', () => bus.emit('quit', 130));\n    process.once('SIGTERM', () => {\n      bus.emit('quit', 143);\n      if (child) {\n        child.kill('SIGTERM');\n      }\n    });\n  });\n}\n\nmodule.exports = run;\n"]},"metadata":{},"sourceType":"script"}
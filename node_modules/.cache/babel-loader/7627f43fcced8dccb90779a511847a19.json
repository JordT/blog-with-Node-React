{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst picomatch = require('picomatch');\n\nconst normalizePath = require('normalize-path');\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\n\n\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {\n  returnIndex: false\n};\n\nconst arrify = item => Array.isArray(item) ? item : [item];\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\n\n\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return string => matcher === string || glob(string);\n  }\n\n  if (matcher instanceof RegExp) {\n    return string => matcher.test(string);\n  }\n\n  return string => false;\n};\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\n\n\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n\n  const _path = isList ? args[0] : args;\n\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n\n  const path = normalizePath(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\n\n\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n\n  const opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  const returnIndex = opts.returnIndex || false; // Early cache for matchers.\n\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG).map(item => item.slice(1)).map(item => picomatch(item, opts));\n  const patterns = mtchers.filter(item => typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG).map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;","map":{"version":3,"sources":["/Users/jordanthomson/code/blog-with-Node-React/node_modules/anymatch/index.js"],"names":["Object","defineProperty","exports","value","picomatch","require","normalizePath","BANG","DEFAULT_OPTIONS","returnIndex","arrify","item","Array","isArray","createPattern","matcher","options","glob","string","RegExp","test","matchPatterns","patterns","negPatterns","args","isList","_path","TypeError","prototype","toString","call","path","index","length","nglob","applied","concat","slice","pattern","anymatch","matchers","testString","opts","mtchers","negatedGlobs","filter","charAt","map","ri","default","module"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var debug = require('debug')('nodemon');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar exists = fs.exists || path.exists;\n\nvar utils = require('../utils');\n\nvar rules = require('../rules');\n\nvar parse = require('../rules/parse');\n\nvar exec = require('./exec');\n\nvar defaults = require('./defaults');\n\nmodule.exports = load;\nmodule.exports.mutateExecOptions = mutateExecOptions;\nvar existsSync = fs.existsSync || path.existsSync;\n\nfunction findAppScript() {\n  // nodemon has been run alone, so try to read the package file\n  // or try to read the index.js file\n  if (existsSync('./index.js')) {\n    return 'index.js';\n  }\n}\n/**\n * Load the nodemon config, first reading the global root/nodemon.json, then\n * the local nodemon.json to the exec and then overwriting using any user\n * specified settings (i.e. from the cli)\n *\n * @param  {Object} settings user defined settings\n * @param  {Function} ready    callback that receives complete config\n */\n\n\nfunction load(settings, options, config, callback) {\n  config.loaded = []; // first load the root nodemon.json\n\n  loadFile(options, config, utils.home, function (options) {\n    // then load the user's local configuration file\n    if (settings.configFile) {\n      options.configFile = path.resolve(settings.configFile);\n    }\n\n    loadFile(options, config, process.cwd(), function (options) {\n      // Then merge over with the user settings (parsed from the cli).\n      // Note that merge protects and favours existing values over new values,\n      // and thus command line arguments get priority\n      options = utils.merge(settings, options); // legacy support\n\n      if (!Array.isArray(options.ignore)) {\n        options.ignore = [options.ignore];\n      }\n\n      if (!options.ignoreRoot) {\n        options.ignoreRoot = defaults.ignoreRoot;\n      } // blend the user ignore and the default ignore together\n\n\n      if (options.ignoreRoot && options.ignore) {\n        if (!Array.isArray(options.ignoreRoot)) {\n          options.ignoreRoot = [options.ignoreRoot];\n        }\n\n        options.ignore = options.ignoreRoot.concat(options.ignore);\n      } else {\n        options.ignore = defaults.ignore.concat(options.ignore);\n      } // add in any missing defaults\n\n\n      options = utils.merge(options, defaults);\n\n      if (!options.script && !options.exec) {\n        var found = findAppScript();\n\n        if (found) {\n          if (!options.args) {\n            options.args = [];\n          } // if the script is found as a result of not being on the command\n          // line, then we move any of the pre double-dash args in execArgs\n\n\n          const n = options.scriptPosition === null ? options.args.length : options.scriptPosition;\n          options.execArgs = (options.execArgs || []).concat(options.args.splice(0, n));\n          options.scriptPosition = null;\n          options.script = found;\n        }\n      }\n\n      mutateExecOptions(options);\n\n      if (options.quiet) {\n        utils.quiet();\n      }\n\n      if (options.verbose) {\n        utils.debug = true;\n      } // simplify the ready callback to be called after the rules are normalised\n      // from strings to regexp through the rules lib. Note that this gets\n      // created *after* options is overwritten twice in the lines above.\n\n\n      var ready = function (options) {\n        normaliseRules(options, callback);\n      }; // if we didn't pick up a nodemon.json file & there's no cli ignores\n      // then try loading an old style .nodemonignore file\n\n\n      if (config.loaded.length === 0) {\n        var legacy = loadLegacyIgnore.bind(null, options, config, ready); // first try .nodemonignore, if that doesn't exist, try nodemon-ignore\n\n        return legacy('.nodemonignore', function () {\n          legacy('nodemon-ignore', function (options) {\n            ready(options);\n          });\n        });\n      }\n\n      ready(options);\n    });\n  });\n}\n/**\n * Loads the old style nodemonignore files which is a list of patterns\n * in a file to ignore\n *\n * @param  {Object} options    nodemon user options\n * @param  {Function} success\n * @param  {String} filename   ignore file (.nodemonignore or nodemon-ignore)\n * @param  {Function} fail     (optional) failure callback\n */\n\n\nfunction loadLegacyIgnore(options, config, success, filename, fail) {\n  var ignoreFile = path.join(process.cwd(), filename);\n  exists(ignoreFile, function (exists) {\n    if (exists) {\n      config.loaded.push(ignoreFile);\n      return parse(ignoreFile, function (error, rules) {\n        options.ignore = rules.raw;\n        success(options);\n      });\n    }\n\n    if (fail) {\n      fail(options);\n    } else {\n      success(options);\n    }\n  });\n}\n\nfunction normaliseRules(options, ready) {\n  // convert ignore and watch options to rules/regexp\n  rules.watch.add(options.watch);\n  rules.ignore.add(options.ignore); // normalise the watch and ignore arrays\n\n  options.watch = options.watch === false ? false : rules.rules.watch;\n  options.ignore = rules.rules.ignore;\n  ready(options);\n}\n/**\n * Looks for a config in the current working directory, and a config in the\n * user's home directory, merging the two together, giving priority to local\n * config. This can then be overwritten later by command line arguments\n *\n * @param  {Function} ready callback to pass loaded settings to\n */\n\n\nfunction loadFile(options, config, dir, ready) {\n  if (!ready) {\n    ready = function () {};\n  }\n\n  var callback = function (settings) {\n    // prefer the local nodemon.json and fill in missing items using\n    // the global options\n    ready(utils.merge(settings, options));\n  };\n\n  if (!dir) {\n    return callback({});\n  }\n\n  var filename = options.configFile || path.join(dir, 'nodemon.json');\n\n  if (config.loaded.indexOf(filename) !== -1) {\n    // don't bother re-parsing the same config file\n    return callback({});\n  }\n\n  fs.readFile(filename, 'utf8', function (err, data) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        if (!options.configFile && dir !== utils.home) {\n          // if no specified local config file and local nodemon.json\n          // doesn't exist, try the package.json\n          return loadPackageJSON(config, callback);\n        }\n      }\n\n      return callback({});\n    }\n\n    var settings = {};\n\n    try {\n      settings = JSON.parse(data.toString('utf8').replace(/^\\uFEFF/, ''));\n\n      if (!filename.endsWith('package.json') || settings.nodemonConfig) {\n        config.loaded.push(filename);\n      }\n    } catch (e) {\n      utils.log.fail('Failed to parse config ' + filename);\n      console.error(e);\n      process.exit(1);\n    } // options values will overwrite settings\n\n\n    callback(settings);\n  });\n}\n\nfunction loadPackageJSON(config, ready) {\n  if (!ready) {\n    ready = () => {};\n  }\n\n  const dir = process.cwd();\n  const filename = path.join(dir, 'package.json');\n  const packageLoadOptions = {\n    configFile: filename\n  };\n  return loadFile(packageLoadOptions, config, dir, settings => {\n    ready(settings.nodemonConfig || {});\n  });\n}\n\nfunction mutateExecOptions(options) {\n  // work out the execOptions based on the final config we have\n  options.execOptions = exec({\n    script: options.script,\n    exec: options.exec,\n    args: options.args,\n    scriptPosition: options.scriptPosition,\n    nodeArgs: options.nodeArgs,\n    execArgs: options.execArgs,\n    ext: options.ext,\n    env: options.env\n  }, options.execMap); // clean up values that we don't need at the top level\n\n  delete options.scriptPosition;\n  delete options.script;\n  delete options.args;\n  delete options.ext;\n  return options;\n}","map":{"version":3,"sources":["/Users/jordanthomson/code/blog-with-Node-React/node_modules/nodemon/lib/config/load.js"],"names":["debug","require","fs","path","exists","utils","rules","parse","exec","defaults","module","exports","load","mutateExecOptions","existsSync","findAppScript","settings","options","config","callback","loaded","loadFile","home","configFile","resolve","process","cwd","merge","Array","isArray","ignore","ignoreRoot","concat","script","found","args","n","scriptPosition","length","execArgs","splice","quiet","verbose","ready","normaliseRules","legacy","loadLegacyIgnore","bind","success","filename","fail","ignoreFile","join","push","error","raw","watch","add","dir","indexOf","readFile","err","data","code","loadPackageJSON","JSON","toString","replace","endsWith","nodemonConfig","e","log","console","exit","packageLoadOptions","execOptions","nodeArgs","ext","env","execMap"],"mappings":"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","sourcesContent":["var debug = require('debug')('nodemon');\nvar fs = require('fs');\nvar path = require('path');\nvar exists = fs.exists || path.exists;\nvar utils = require('../utils');\nvar rules = require('../rules');\nvar parse = require('../rules/parse');\nvar exec = require('./exec');\nvar defaults = require('./defaults');\n\nmodule.exports = load;\nmodule.exports.mutateExecOptions = mutateExecOptions;\n\nvar existsSync = fs.existsSync || path.existsSync;\n\nfunction findAppScript() {\n  // nodemon has been run alone, so try to read the package file\n  // or try to read the index.js file\n  if (existsSync('./index.js')) {\n    return 'index.js';\n  }\n}\n\n/**\n * Load the nodemon config, first reading the global root/nodemon.json, then\n * the local nodemon.json to the exec and then overwriting using any user\n * specified settings (i.e. from the cli)\n *\n * @param  {Object} settings user defined settings\n * @param  {Function} ready    callback that receives complete config\n */\nfunction load(settings, options, config, callback) {\n  config.loaded = [];\n  // first load the root nodemon.json\n  loadFile(options, config, utils.home, function (options) {\n    // then load the user's local configuration file\n    if (settings.configFile) {\n      options.configFile = path.resolve(settings.configFile);\n    }\n    loadFile(options, config, process.cwd(), function (options) {\n      // Then merge over with the user settings (parsed from the cli).\n      // Note that merge protects and favours existing values over new values,\n      // and thus command line arguments get priority\n      options = utils.merge(settings, options);\n\n      // legacy support\n      if (!Array.isArray(options.ignore)) {\n        options.ignore = [options.ignore];\n      }\n\n      if (!options.ignoreRoot) {\n        options.ignoreRoot = defaults.ignoreRoot;\n      }\n\n      // blend the user ignore and the default ignore together\n      if (options.ignoreRoot && options.ignore) {\n        if (!Array.isArray(options.ignoreRoot)) {\n          options.ignoreRoot = [options.ignoreRoot];\n        }\n        options.ignore = options.ignoreRoot.concat(options.ignore);\n      } else {\n        options.ignore = defaults.ignore.concat(options.ignore);\n      }\n\n\n      // add in any missing defaults\n      options = utils.merge(options, defaults);\n\n      if (!options.script && !options.exec) {\n        var found = findAppScript();\n        if (found) {\n          if (!options.args) {\n            options.args = [];\n          }\n          // if the script is found as a result of not being on the command\n          // line, then we move any of the pre double-dash args in execArgs\n          const n = options.scriptPosition === null ?\n            options.args.length : options.scriptPosition;\n\n          options.execArgs = (options.execArgs || [])\n            .concat(options.args.splice(0, n));\n          options.scriptPosition = null;\n\n          options.script = found;\n        }\n      }\n\n      mutateExecOptions(options);\n\n      if (options.quiet) {\n        utils.quiet();\n      }\n\n      if (options.verbose) {\n        utils.debug = true;\n      }\n\n      // simplify the ready callback to be called after the rules are normalised\n      // from strings to regexp through the rules lib. Note that this gets\n      // created *after* options is overwritten twice in the lines above.\n      var ready = function (options) {\n        normaliseRules(options, callback);\n      };\n\n      // if we didn't pick up a nodemon.json file & there's no cli ignores\n      // then try loading an old style .nodemonignore file\n      if (config.loaded.length === 0) {\n        var legacy = loadLegacyIgnore.bind(null, options, config, ready);\n\n        // first try .nodemonignore, if that doesn't exist, try nodemon-ignore\n        return legacy('.nodemonignore', function () {\n          legacy('nodemon-ignore', function (options) {\n            ready(options);\n          });\n        });\n      }\n\n      ready(options);\n    });\n  });\n}\n\n/**\n * Loads the old style nodemonignore files which is a list of patterns\n * in a file to ignore\n *\n * @param  {Object} options    nodemon user options\n * @param  {Function} success\n * @param  {String} filename   ignore file (.nodemonignore or nodemon-ignore)\n * @param  {Function} fail     (optional) failure callback\n */\nfunction loadLegacyIgnore(options, config, success, filename, fail) {\n  var ignoreFile = path.join(process.cwd(), filename);\n\n  exists(ignoreFile, function (exists) {\n    if (exists) {\n      config.loaded.push(ignoreFile);\n      return parse(ignoreFile, function (error, rules) {\n        options.ignore = rules.raw;\n        success(options);\n      });\n    }\n\n    if (fail) {\n      fail(options);\n    } else {\n      success(options);\n    }\n  });\n}\n\nfunction normaliseRules(options, ready) {\n  // convert ignore and watch options to rules/regexp\n  rules.watch.add(options.watch);\n  rules.ignore.add(options.ignore);\n\n  // normalise the watch and ignore arrays\n  options.watch = options.watch === false ? false : rules.rules.watch;\n  options.ignore = rules.rules.ignore;\n\n  ready(options);\n}\n\n/**\n * Looks for a config in the current working directory, and a config in the\n * user's home directory, merging the two together, giving priority to local\n * config. This can then be overwritten later by command line arguments\n *\n * @param  {Function} ready callback to pass loaded settings to\n */\nfunction loadFile(options, config, dir, ready) {\n  if (!ready) {\n    ready = function () { };\n  }\n\n  var callback = function (settings) {\n    // prefer the local nodemon.json and fill in missing items using\n    // the global options\n    ready(utils.merge(settings, options));\n  };\n\n  if (!dir) {\n    return callback({});\n  }\n\n  var filename = options.configFile || path.join(dir, 'nodemon.json');\n\n  if (config.loaded.indexOf(filename) !== -1) {\n    // don't bother re-parsing the same config file\n    return callback({});\n  }\n\n  fs.readFile(filename, 'utf8', function (err, data) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        if (!options.configFile && dir !== utils.home) {\n          // if no specified local config file and local nodemon.json\n          // doesn't exist, try the package.json\n          return loadPackageJSON(config, callback);\n        }\n      }\n      return callback({});\n    }\n\n    var settings = {};\n\n    try {\n      settings = JSON.parse(data.toString('utf8').replace(/^\\uFEFF/, ''));\n      if (!filename.endsWith('package.json') || settings.nodemonConfig) {\n        config.loaded.push(filename);\n      }\n    } catch (e) {\n      utils.log.fail('Failed to parse config ' + filename);\n      console.error(e);\n      process.exit(1);\n    }\n\n    // options values will overwrite settings\n    callback(settings);\n  });\n}\n\nfunction loadPackageJSON(config, ready) {\n  if (!ready) {\n    ready = () => { };\n  }\n\n  const dir = process.cwd();\n  const filename = path.join(dir, 'package.json');\n  const packageLoadOptions = { configFile: filename };\n  return loadFile(packageLoadOptions, config, dir, settings => {\n    ready(settings.nodemonConfig || {});\n  });\n}\n\nfunction mutateExecOptions(options) {\n  // work out the execOptions based on the final config we have\n  options.execOptions = exec({\n    script: options.script,\n    exec: options.exec,\n    args: options.args,\n    scriptPosition: options.scriptPosition,\n    nodeArgs: options.nodeArgs,\n    execArgs: options.execArgs,\n    ext: options.ext,\n    env: options.env,\n  }, options.execMap);\n\n  // clean up values that we don't need at the top level\n  delete options.scriptPosition;\n  delete options.script;\n  delete options.args;\n  delete options.ext;\n\n  return options;\n}\n"]},"metadata":{},"sourceType":"script"}
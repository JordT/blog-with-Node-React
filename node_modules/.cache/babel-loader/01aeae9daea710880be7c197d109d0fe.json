{"ast":null,"code":"/**\n * Manages the internal config of nodemon, checking for the state of support\n * with fs.watch, how nodemon can watch files (using find or fs methods).\n *\n * This is *not* the user's config.\n */\nvar debug = require('debug')('nodemon');\n\nvar load = require('./load');\n\nvar rules = require('../rules');\n\nvar utils = require('../utils');\n\nvar pinVersion = require('../version').pin;\n\nvar command = require('./command');\n\nvar rulesToMonitor = require('../monitor/match').rulesToMonitor;\n\nvar bus = utils.bus;\n\nfunction reset() {\n  rules.reset();\n  config.dirs = [];\n  config.options = {\n    ignore: [],\n    watch: [],\n    monitor: []\n  };\n  config.lastStarted = 0;\n  config.loaded = [];\n}\n\nvar config = {\n  run: false,\n  system: {\n    cwd: process.cwd()\n  },\n  required: false,\n  dirs: [],\n  timeout: 1000,\n  options: {}\n};\n/**\n * Take user defined settings, then detect the local machine capability, then\n * look for local and global nodemon.json files and merge together the final\n * settings with the config for nodemon.\n *\n * @param  {Object} settings user defined settings for nodemon (typically on\n *  the cli)\n * @param  {Function} ready callback fired once the config is loaded\n */\n\nconfig.load = function (settings, ready) {\n  reset();\n  var config = this;\n  load(settings, config.options, config, function (options) {\n    config.options = options;\n\n    if (options.watch.length === 0) {\n      // this is to catch when the watch is left blank\n      options.watch.push('*.*');\n    }\n\n    if (options['watch_interval']) {\n      // jshint ignore:line\n      options.watchInterval = options['watch_interval']; // jshint ignore:line\n    }\n\n    config.watchInterval = options.watchInterval || null;\n\n    if (options.signal) {\n      config.signal = options.signal;\n    }\n\n    var cmd = command(config.options);\n    config.command = {\n      raw: cmd,\n      string: utils.stringify(cmd.executable, cmd.args)\n    }; // now run automatic checks on system adding to the config object\n\n    options.monitor = rulesToMonitor(options.watch, options.ignore, config);\n    var cwd = process.cwd();\n    debug('config: dirs', config.dirs);\n\n    if (config.dirs.length === 0) {\n      config.dirs.unshift(cwd);\n    }\n\n    bus.emit('config:update', config);\n    pinVersion().then(function () {\n      ready(config);\n    }).catch(e => {\n      // this doesn't help testing, but does give exposure on syntax errors\n      console.error(e.stack);\n      setTimeout(() => {\n        throw e;\n      }, 0);\n    });\n  });\n};\n\nconfig.reset = reset;\nmodule.exports = config;","map":{"version":3,"sources":["/Users/jordanthomson/code/blog-with-Node-React/node_modules/nodemon/lib/config/index.js"],"names":["debug","require","load","rules","utils","pinVersion","pin","command","rulesToMonitor","bus","reset","config","dirs","options","ignore","watch","monitor","lastStarted","loaded","run","system","cwd","process","required","timeout","settings","ready","length","push","watchInterval","signal","cmd","raw","string","stringify","executable","args","unshift","emit","then","catch","e","console","error","stack","setTimeout","module","exports"],"mappings":"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","sourcesContent":["/**\n * Manages the internal config of nodemon, checking for the state of support\n * with fs.watch, how nodemon can watch files (using find or fs methods).\n *\n * This is *not* the user's config.\n */\nvar debug = require('debug')('nodemon');\nvar load = require('./load');\nvar rules = require('../rules');\nvar utils = require('../utils');\nvar pinVersion = require('../version').pin;\nvar command = require('./command');\nvar rulesToMonitor = require('../monitor/match').rulesToMonitor;\nvar bus = utils.bus;\n\nfunction reset() {\n  rules.reset();\n\n  config.dirs = [];\n  config.options = { ignore: [], watch: [], monitor: [] };\n  config.lastStarted = 0;\n  config.loaded = [];\n}\n\nvar config = {\n  run: false,\n  system: {\n    cwd: process.cwd(),\n  },\n  required: false,\n  dirs: [],\n  timeout: 1000,\n  options: {},\n};\n\n/**\n * Take user defined settings, then detect the local machine capability, then\n * look for local and global nodemon.json files and merge together the final\n * settings with the config for nodemon.\n *\n * @param  {Object} settings user defined settings for nodemon (typically on\n *  the cli)\n * @param  {Function} ready callback fired once the config is loaded\n */\nconfig.load = function (settings, ready) {\n  reset();\n  var config = this;\n  load(settings, config.options, config, function (options) {\n    config.options = options;\n\n    if (options.watch.length === 0) {\n      // this is to catch when the watch is left blank\n      options.watch.push('*.*');\n    }\n\n    if (options['watch_interval']) { // jshint ignore:line\n      options.watchInterval = options['watch_interval']; // jshint ignore:line\n    }\n\n    config.watchInterval = options.watchInterval || null;\n    if (options.signal) {\n      config.signal = options.signal;\n    }\n\n    var cmd = command(config.options);\n    config.command = {\n      raw: cmd,\n      string: utils.stringify(cmd.executable, cmd.args),\n    };\n\n    // now run automatic checks on system adding to the config object\n    options.monitor = rulesToMonitor(options.watch, options.ignore, config);\n\n    var cwd = process.cwd();\n    debug('config: dirs', config.dirs);\n    if (config.dirs.length === 0) {\n      config.dirs.unshift(cwd);\n    }\n\n    bus.emit('config:update', config);\n    pinVersion().then(function () {\n      ready(config);\n    }).catch(e => {\n      // this doesn't help testing, but does give exposure on syntax errors\n      console.error(e.stack);\n      setTimeout(() => { throw e; }, 0);\n    });\n  });\n};\n\nconfig.reset = reset;\n\nmodule.exports = config;\n"]},"metadata":{},"sourceType":"script"}